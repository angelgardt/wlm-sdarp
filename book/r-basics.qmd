# Основы R {#r-basics}

{{< include other/_symbols.qmd >}}

```{r opts, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, error=FALSE}
knitr::opts_chunk$set(echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, error=FALSE)
```

:::{.intro}
С R и RStudio мы познакомились. Теперь надо освоить основы. 
:::

## Работа в консоли {#r-intro-console}

:::{.lab-junior}
:::

<!-- > Красоту навели --- пора бы и серьезными вещами заняться. -->

Мы начнем работу с R в консоли, хотя такой вариант практически на практике не применяется. Тем не менее, во-первых, надо познакомиться с тем, как консоль работает, а во-вторых, избавиться от «страха консоли», если вдруг он у вас есть.

Когда вы открыли RStudio, R вывел вам в консоль приветственное сообщение примерно такого содержания:

```

R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin20

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.
```

В принципе, его можно проигнорировать --- в нем некая техническая информация. Всё это можно достать отдельно при необходимости. Сейчас сосредоточимся на том, что отображается после сообщения --- маленькая неприметная, но важнейшая стрелочка (@fig-console-waiting). Она обозначает, что R сейчас ничего не делает и ожидает новую команду.

![Ожидание команды](img/r-intro/console-waiting.gif){#fig-console-waiting}

Это дефолтное состояние консоли. Чтобы выполнить какую-либо команду, надо напечатать её в консоли и нажать `Enter`. Например, вы хотите напечатать в консоль `0`. Для этого есть команда (функция) `print()`. Введя в консоль `print(0)` и нажав `Enter`, мы получим следующий результат (@fig-console-print).

![Выполнение команды. После написания команды нажата клавиша `Enter`](img/r-intro/console-print.gif){#fig-console-print}

Однако состояние со стрелочкой не единственное. На месте стрелочки может стоять плюсик. Это значит, что R нашел окончание команды, и ожидает, когда вы её допишете, чтобы он мог отправить её выполняться. Например, вы всё ещё хотите напечатать в консоль `0`, но забыли закрыть скобку в функции `print()`. Это будет выглядеть так (@fig-console-plus). Если после «плюса» дописать скобку и нажать `Enter`, то команда выполнится.

![Ожидание окончания команды. После дописывания скобки нажата клавиша `Enter`](img/r-intro/console-plus.gif){#fig-console-plus}

Если вы не хотите, чтобы команды выполнялась, то её можно прервать, нажав клавишу `Esc` (@fig-console-plus-esc).

![Прерывание команды. После перехода в ожидание окончания команды нажата клавиша `Esc`](img/r-intro/console-plus-esc.gif){#fig-console-plus-esc}

Есть ещё одно состояние, когда не отображается ни стрелочка, ни плюс. Это значит, что вы дали R большую сложную команду, и он теперь занят --- вот прямо сейчас её выполняет. Надо подождать, и консоль вернется в дефолтное состояние.

Ура, мы разобрались, что происходит в консоли, теперь приступим собственно к R.



:::{.callout-note}
###### Далее: код

Отображать выполнение кода с помощью гифок, конечно, крайне неудобно. Далее будет использоваться следующий формат:

```{r}
print(0)
```

Покрашенное разными цветами --- это сам код. Ниже однотонное --- результат его выполнения, отображаемый в консоли.

:::



### Арифметические операции {#r-intro-arithm}

:::{.lab-junior}
:::

В R присутствуют все стандарные арифметические операции --- сложение (`+`), вычитание (`-`), умножение (`*`), деление (`/`) и возведение в степень (`^`). Выполняются весьма предсказуемо.

:::{#lst-arithm-opetaions}
```{r arithm-operations}
2 + 2
10 - 3
4 * 6
8 / 5
2 ^ 10
```

Базовые математические операции
:::

Есть также два специальных деления --- целочисленное (`%/%`) и взятие остатка от деления (`%%`).

:::{#lst-div-mod}
```{r div-mod}
5 %/% 2
5 %% 2
```

Целочисленное деление и взятие остатка от деления
:::

:::{#exr-basic-arithm}
Вычислите в R:

a. $32 + 64$
a. $-11 + 91$
a. $5 - 7$
a. $18 - 47$
a. $9 \cdot 12$
a. $616 : 55$
a. $25 \mod 6$
a. $8^{3}$
a. $-2^{-2}$
a. $(-2)^{-2}$

Оператор $\mathrm{mod}$ обозначает взятие остатка от деления.

:::

:::{.solution}
```{r basic-arithm-solution}
32 + 64
-11 + 91
5 - 7
18 - 47
9 * 12
616 / 55
25 %% 6
8 ^ 3
-2 ^ -2
(-2) ^ -2
```
:::

![Как изучать программирование? [Источник](https://www.orlybooks.com/books/changing-stuff-and-seeing)](img/r-intro/orly-changing-stuff-and-seeing.png)

В R есть скобки --- `()` --- их назначение такое же, как и в математике. Порядок выполнения арифметических действий (он же приоритет операторов, operator precedence) тоже как в математике[^operator_precendence].

[^operator_precendence]: [Не во всех](https://www.quora.com/Do-all-programming-languages-use-the-same-operator-precedence-rule-If-yes-or-no-why) языках программирования это так.

:::{#lst-operator-precedence}
```{r operator-precedence}
4 * 4 + 4
4 * (4 + 4)
5 / 5 ^ 5
(5 / 5) ^ 5
```

Скобки и приоритет операторов
:::

:::{#exr-operator-precedence}
Вычислите в R:

a. $\displaystyle \frac{46 \cdot 3}{13 + 4}$
a. $2^{\frac{6}{11}}$
a. $\displaystyle \frac{-77 + 101}{-12^2}$
a. $\displaystyle -77 + \left( \frac{101}{-12} \right)^2$
:::

:::{.solution}
```{r operator-precedence-solution}
46 * 3 / (13 + 4)
2 ^ (6 / 11)
(-77 + 101) / (-12 ^ 2)
-77 + (101 / -12) ^ 2
```
:::



### Логические операции {#r-intro-logic}

:::{.lab-junior}
:::

Числа, как вы знаете, можно не только складывать, умножать, делить и т.д., но ещё и сравнивать друг с другом. Для этого существуют логические операторы, коих в R шесть штук:

* строгое неравенство
    * «больше» (`>`)
    * «меньше» (`<`)
* нестрогое неравенство
    * «больше или равно» (`>=`)
    * «меньше или равно» (`<=`)
* равенство
    * «равно [ли]» (`==`)
    * «не равно» (`!=`)

Работают они вновь весьма предсказуемо и возвращают `TRUE`, когда заданное сравнение верно, и `FALSE`, когда оно неверно.

:::{#lst-logic-operations}
```{r logic-operations}
2 > -3
6 >= 6
12 < 12
-5 <= -4
7 == 1
8 != 9
```

Логические операции
:::

Приоритет логических операторов _ниже_, чем арифметических.

:::{#lst-logic-vs-arithm}
```{r logic-vs-arithm}
2 != 2 + 1
6 < 8 - 2
4 * 3 == 12
6 ^ (6 == 6) ## это почему работает???
```

Приоритет логических операторов
:::

:::{#exr-operator-logic-operations}
Проверьте, справедливы ли утверждения --- вдруг R с ума сошёл?

a. $\displaystyle 16 - 8 \cdot 2 > 0$
a. $\displaystyle \frac{1}{1 + 1} < 1$
a. $\displaystyle \frac{55}{11} = 5$
a. $\displaystyle \frac{41}{64 - 4^3} = 0$
:::

:::{.solution}
```{r logic-operations-solution}
16 - 8 * 2 > 0
1 / (1 + 1) < 1
55 / 11 == 5
41 / (64 - 4^3) == 0
```
:::

:::{.callout-tip}
###### Приоритет операторов более широко
У нас появился новый --- и не последний --- тип операторов. На самом деле, операторов в R больше, и мы с ними постепенно будем знакомиться.

Если вы не уверенны, в каком порядке операторы будут работать, используйте скобки. Или можете посмотреть список операторов по приоритету по команде `?Syntax`.
:::


:::{.callout-caution}
###### `==` vs `=`

Обращу внимание, что для сравнения на равенство используется двойное равно --- `==`. Одинарное равно имеет другой смысл (см. [далее](#r-intro-assignment)).

В принципе, если вы случайно опечатаетесь, катастрофических последствий это, скорее всего, не вызовет --- код упадет в ошибкой (@lst-equal-comparison). Хотя могло бы...[^rintro-redundancy]

![Code review --- это полезно. [Источник](https://www.reddit.com/r/ProgrammerHumor/comments/4x26u3/this_is_why_code_reviews_are_a_good_thing/)](img/r-intro/robots-kill-humans.png)
:::

[^rintro-redundancy]: К слову, если мы внимательно всмотримся в код на картинке, то обнаружим, что фатальных последствий можно было избежать, убрав избыточность кода в условном операторе --- сравнение с `true` бессмысленно, так как `isCrazyMurderingRobot` уже является логическим значением, и его можно использовать в условии напрямую. 🤦

:::{#lst-equal-comparison}
```{r equal-comparison, error=TRUE}
2 == 2
2 = 2
```

Двойное (`==`) и одинарное (`=`) равенство
:::

:::{.callout-note}
### Ещё логические операции

К логическим операциям также относятся `&` и `|` --- И и ИЛИ. Однако чтобы не перегружать вводный раздел, их мы обсудим [чуть позже вместе с соответствующим типом данных](r-datatypes.qmd#r-datatypes-logical).

:::



### История команд {#r-intro-rhistory}

:::{.lab-junior}
:::

Выше я отмечал, что сделанно в консоли бесследно пропадает. Это почти так, но если нам всё же надо воскресить предыдущие команды, то это можно сделать стрелками вверх и вниз (`↑`, `↓`). Например, мы посчитали вот это:

```{r}
3 - 3
6 + 14
9 / 12
3 * 5
```

и теперь хотим вернуться ещё раз пересчитать `9 / 12` --- вдруг ошиблись... Если мы, стоя в консоли, два раза жмякнем стрелку вверх, команда вновь отобразится в консоли (@fig-rhistory).

Такое иногда бывает полезно, когда вы, скажем, писали большой скрипт, потом что-то мелкое промежуточное посчитали в консоли, затем вернулись обратно к скрипту и забыли, что там получилось в вычислениях. Однако лучше все фиксировать в скрипте, чтобы потом мучительно не вспоминать, а что вы там конкретно промежуточно считали.

![История команд. Предыдущие команды можно вызвать в консоль с помощью клавиш `↑` и `↓`.](img/r-intro/rhistory.gif){#fig-rhistory}

:::{.callout-note collapse="true"}
###### `History` & `.Rhistory`

Историю команд можно найти на вкладке `History` третьего окна (@fig-rstudio-interface). Также существует файл `.Rhistory`, в котором также хранится история команд --- его можно найти в папке пользователя или рабочей директории. Скорее всего, он не будет отображаться в Проводнике/Finder, так как является скрытым. Чтобы его увидеть, нужно включить отображение скрытых файлов на компьютере. Или же посмотреть во вкладку `Files` четвертого окна (@fig-rstudio-interface) --- там отображаются даже скрытые файлы.
:::




## Работа в скрипте {#r-intro-script}

:::{.lab-junior}
:::

Хотя у нас и есть возможность вернуться к предыдущим командам, в реальной жизни это нас слабо спасает. Удобнее фиксировать последовательность команд в некотором файле, создавая *скрипт*, а из него уже отправлять команды на выполнение в консоль. Это ровно то, зачем нам нужно окно `Code Editor` (первое в интерфейсе --- [-@fig-rstudio-interface]), в котором и живёт скрипт.

В скрипте можно выполнить всё то же самое, что мы делали в консоли. Есть только одно отличие:

* в консоли мы выполняли команду, нажимая `Enter`;
* в скрипте, так как мы теперь находится в редакторе кода, `Enter` отвечает за перевод строки --- как и в любых других текстовых редакторах;
* чтобы отправить команду на исполнение в консоль, необходимо нажать сочетание клавиш `Ctrl` + `Enter` (`⌘` + `Enter`).

Кроме того, скрипт предоставляет нам более широкую вариативность того, что можно отправить на выполнение.

* Если курсор просто стоит на некоторой строке, то выполнится вся строка, а курсор перейдет на следующую строку[^stay_on_line] (@fig-run-line).
* Если выделена часть строки, то выполнился именно эта часть, курсор и выделение останутся на месте (@fig-run-part-of-line).
* Если выделено несколько строк, то выполняться все они, курсов и выделение останутся на месте (@fig-run-two-lines).

[^stay_on_line]: Если нужно оставить курсор на текущей строке, используйте `Alt` + `Enter` (`Option` + `Enter`).

:::{#fig-run-from-script layout-nrow=3}
![Выполнение строки. Первый раз нажат `Enter`, второй раз --- `Ctrl` + `Enter`](img/r-intro/run-line.gif){#fig-run-line}

![Выполнение части строки. Первый раз исполняется вся строка, второй --- только выделенна часть](img/r-intro/run-part-of-line.gif){#fig-run-part-of-line}

![Выполнение нескольких строк. Последовательно выполненые обе выделенные строки](img/r-intro/run-two-lines.gif){#fig-run-two-lines}

Выполнение команд из скрипта
:::

Вот и, пожалуй, все отличия скрипта от консоли.



### Математические функции {#r-intro-mathfunc}

:::{.lab-junior}
:::

Окей, до сего момента мы ограничивались простыми вычислениями. Но что если нам надо посчитать что-то более сложное? Например, $\sqrt{32}$ или $\log_4 13$.

Мы, конечно, при желании переиграем R, так как мы помним[^formulas], что

$$
\sqrt{x} = x^{\frac{1}{2}}
$$

[^formulas]: Если забыли, то есть [приложение](appendix-formulas.qmd).

Поэтому мы можем вычислить $\sqrt{32}$ так:

```{r sqrt-as-power}
32^(0.5)
```

Однако это не очень удобно. Плюс с логарифмом такой трюк уже не пройдет --- нам нужны _функции_.

В школьной математике вводилось неким образом понятие функции, но прямо сейчас оно нам не очень нужно. Мы уделим более пристальное внимание функциям в R и в математике позднее. Пока что нам будет достаточно вспомнить, как обозначались функции в математике --- полагаю, что как-то так:

$$
f(x),
$$

где $f$ --- название функции, а $x$ --- её аргумент. Скажем, можно вспомнить --- с болью или с восторгом --- следующие примеры: $\sin(x)$, $\cos(x)$ и $\tan(x)$[^tan]. Но всё же вернемся к вычислению корня.

[^tan]: В этой книжке для тангенса и контангенса используются обозначения, принятые в современной зарубежной математической литературе --- $\tan$ и $\cot$ соответственно. Они идентичный по смыслу обозначениям, используемым в отечественной литературе --- $\text{tg}$ и $\text{ctg}$.

В R синтаксис функции довольно стандартный:

:::{#lst-intro-fun}
```{r intro-fun, eval=FALSE}
function(arg1, arg2, ...)
```

Синтаксис функции
:::

Здесь `function` является *названием (именем) функции*, а `arg1`, `arg2` и т. д. её *аргументами*. Аргументы функции указываются в скобках после её названия. В простейшем случае это будет выглядеть так:

:::{#lst-sqrt}
```{r sqrt}
sqrt(32)
```

Функция квадратного корня. Вычисление $\sqrt{32}$
:::

Функция `sqrt()` имеет только один аргумент и вычисляет квадратный корень из переданного ей числа. Как можно заметить, результат совпадает с `32^(0.5)`.

Аналогично можно вычислить, например, значения тригонометрических функций[^trig-arg]:

[^trig-arg]: Число, передаваемое в качестве аргумента тригонометрическим функциям, обрабатывается ими как *радианная* мера угла.

:::{#lst-trig}
```{r trig}
sin(10)
cos(10)
tan(10)
```

Базовые тригонометрические функции
:::

Думаю, что здесь логика работы довольно понятна. А что же с логарифмом?

Мы желали вычислить $\log_4 13$. Согласно математике, это $1.85$ с копейками. Для вычисления логарифма, конечно же, существует функция `log()`, однако у «математического» логарифма два аргумента: собственно аргумент --- в нашем случае $13$ --- и основание логарифма --- в нашем случае $4$. Общий синтаксис (@lst-intro-fun) нам подсказывает, что функция может принимать несколько аргументов, но будет ли разница между `log(13, 4)` и `log(4, 13)`? В математике мы сначала пишем основание логарифма, затем число, от которого его нужно вычислить --- сохраняется ли этот порядок при использовании функции в R?


#### Help {#r-intro-help}

Чтобы ответить на эти вопросы, нам необходимо ненадолго отвлечься на важную вкладку чётвертого окна интерфейса RStudio (@fig-rstudio-interface) --- **Help**. Оно, как мы отмечали выше, содержит документацию по R (@fig-r-intro-help).

![Вкладка Help](img/r-intro/r-help.png){#fig-r-intro-help}

Чтобы получить Help по функции можно использовать один и вариантов:

* перейти в это окно и ввести название функции в строке поиска в правом верхнем углу
* выполнить в скрипте/консоли команду `help(function_name)`
    * например, сейчас нам нужен `help(log)`
* выполнить в скрипте/консоли команду `?function_name`
    * аналогично, сейчас нам нужен `?log`

Все варианты дадут один и тот же результат (@fig-r-intro-help-log).

![Help по функции `log()`](img/r-intro/r-help-log.png){#fig-r-intro-help-log}

***

Ура, мы познакомились с тем, как работает Help. Документация пишется по определенной структуре и содержит разделы *Description*, *Usage*, *Arguments*, *Details*, *Examples* и другие. В частности, из раздела *Arguments* для функции `log()` мы выясняем, что у неё есть два аргумента --- `x` и `base` --- что соответствует математике. В **Usage** мы также обнаруживаем, что сначала функции передается `x`, а затем `base`. Давайте проверим, что это так работает --- посчитаем $\log_4 13$.

:::{#lst-log}
```{r, log}
log(x = 13, base = 4)
```
Функция логарифма
:::

Во истину всё вычисляется.

:::{.callout-note collapse="true"}
###### Математические операторы как функции

Отметим одну интересную вещь: привычные нам *математические операторы также являются функциями*.

Мы привыкли записывать сложение, вычитание, умножение, деление и возведение в степень так:

```{r arithm-ops}
2 + 3
2 - 3
2 * 3
2 / 3
2 ^ 3
```

Однако мы можем использовать синтаксис функции для выполнения этих же операций, только сами операторы-функции необходимо будет обернуть в бэктики --- обратные кавычки:

```{r arithm-funs}
`+`(2, 3)
`-`(2, 3)
`*`(2, 3)
`/`(2, 3)
`^`(2, 3)
```

Это довольно экзотические конструкции и используются они крайне редко --- при решении экзотических задач --- просто потому что привычный синтаксис удобнее.

Можно заметить и ещё кое-что: эти функции принимают на вход **строго два аргумента**[^unary-ops], поэтому их называют **бинарными операторами**:

```{r arithm-funs-binary, error=TRUE}
`+`(2, 3, 4)
`*`(2, 3, 4)
```

:::

[^unary-ops]: Если быть ещё более детальным, то существует *унарный минус* --- это тот, что стоит перед отрицательными числами (например, $-2$). Попробуйте выполнить ``` `-`(2) ``` и ``` `*`(2) ``` и сравните результаты.



#### Передача аргументов {#r-intro-func-args}

В примере [-@lst-log] мы передали функции `log()` её аргументы **по именам**. Для краткости часто используются передачу аргументов **по позиции** (@lst-log-position).

:::{#lst-log-position}
```{r, log-position}
log(13, 4)
```
Функция логарифма. Передача аргументов по позиции
:::

Обратите внимание, что в случае передачи аргументов по имени их порядок можно изменить, и результат останется прежним. В случае передачи по позиции результат при перестановке аргументов изменится (@lst-log-position-change).

:::{#lst-log-position-change}
```{r, log-position-change}
log(x = 13, base = 4)
log(base = 4, x = 13)
log(13, 4) ## x = 13, base = 4
log(4, 13) ## x = 4, base = 13
```
Функция логарифма. Передача аргументов по позиции и по имени
:::

Окей, с работой функции `log()` мы подробно разобрались. Другие функции работают абсолютно аналогично, разве что аргументов может быть значительно больше, но с этим мы ещё покопаемся.

И всё же вот вам две интересности:

:::{#lst-log-nobase-nox}
```{r log-nobase}
log(13) ## как сработало?
```

```{r log-nox, error=TRUE}
log(base = 4) ## что случилось?
```

Функция логарифма. Вызов без одного из аргументов
:::


#### Дефолтные значения и обязательные аргументы {#r-intro-func-default-values}

Чтобы разобраться со случаями в [-@lst-log-nobase-nox], нам придется вновь заглянуть в Help, а именно в раздел Usage, конкретно в первую его строку:

```{r, eval=FALSE}
log(x, base = exp(1))
```

Здесь мы наблюдаем следующее:

* функция `log()` принимает два аргумента --- `x` и `base`,
* аргумент `x` **является обязательным**, так как **не имеет дефолтного значения**,
* аргумент `base` **не является** обязательным, так как **имеет** дефолтное значение.

То есть, если мы попытаемся вызывать функцию `log()` без аргумента `x`, она не сможет выполниться и возникнет ошибка:

```{r log-nox-2, error=TRUE}
log(base = 6)
```

Если же мы попытаемся вызвать эту функцию без указания основания логарифма, то она прекрасно отработает, взяв за значение аргумента `base` нечто, получаемое в результате работы функции `exp(1)`:

```{r log-nobase-2, error=TRUE}
log(2)
```

Что же такое `exp(1)`? Можно вновь обратиться в Help, а можно просто выполнить эту функцию:

```{r log-exp-1, error=TRUE}
exp(1)
```

Мы получили значение $2.718282$, которое в математике обозначается $e$ и является *основанием натуральных логарифмов*.

Делаем следующие наблюдения:

:::{.callout-warning appearance="minimal"}

* функции не работают без обязательных аргументов
* обязательными аргументами являются те, у которых нет значения по умолчанию (дефолтного значения)
* в качестве значения аргументов функции можно передать результат работы другой функции

:::

В частности к последнему пункту можно привести следующий пример --- $\log_{e^2} \sqrt{2}$:

```{r log-e-sqrt}
log(sqrt(2), exp(2))
```

:::{#exr-math-functions}
Вычислите в R:

a. $\displaystyle \log_{\sqrt{2}}11$
a. $\displaystyle \frac{e^2}{2 \sqrt{6} - \ln 4}$
a. $\displaystyle \tan2 - \tan (-2)$
a. $\displaystyle \sin \frac{\pi}{4}$
:::

:::{.solution}
```{r math-function-solution}
log(11, sqrt(2))
exp(2) / (2 * sqrt(6) - log(4))
tan(2) - tan(-2)
sin(pi/4) ## можно и так --- sqrt(2) / 2
```
:::



### Присваивание (assignment) {#r-intro-assignment}

:::{.lab-junior}
:::

Результаты вычислений и преобразований хотелось бы сохранять, поэтому в R существует **оператор присваивания (assignment)** `<-`, который вводится[^change-shortcuts] с помощью сочетания клавиш `Alt` + `-` (`Option` + `-`):

[^change-shortcuts]: Изменить сочетания клавиш можно в `Tools` → `Modify Keyboard Shortcuts...`

:::{#lst-assignment}
```{r}
x <- 5
y <- 4 * 8
```

Присваивание значений переменным и создание объектов.
:::

Давайте пристально посмотрим, что происходит в примере [-@lst-assignment]:

* мы решаем создать две **переменные** --- `x` и `y`
* эти переменные будут именовать два **объекта** --- числа `5` и `32`
    * первое помещено в переменную напрямую, второе создано вычислением `4 * 8`
* созданные объекты отображаются во вкладке **Environment** третьего окна RStudio (@fig-rstudio-interface)


**Объектом** в R может быть абсолютно всё, что угодно --- число, строка, вектор, матрица, таблица, список, функция и другие более сложные и специфические штуки. Мы не будем погружаться в программистские детали и аровское закулисье, поэтому всё, что валяется в Environment для нас есть объект.

С созданными объектами можно далее успешно работать. Например, созданные переменные `x` и `y` использоваться во всяких вычислениях:

```{r vars-in-funs}
x + y
sqrt(x)
log(y, base = x)
```

:::{.callout-note}
###### `<-` vs `=`

Многие задаются вопросом: почему бы не использовать[^underscore-assign] знак равенства `=` в качестве оператора присваивания? Python, к примеру, отлично так и живет.

В принципе, можно использовать и `=` --- работать это будет абсолютно точно так же:

```{r equal-assign}
w <- 4^2
w
z = 4^2
z
```

Однако остается вопрос *стилистики кода*. В R-сообществе принято разделять *присваивание значения* и *передачу значений аргументов функций*. Для первого используется `<-`, для второго --- `=`, как мы делали, скажем, в [-@lst-log-position-change].

Если же вы всё же решите использовать для присваивания `=`, вам, конечно, никто ничего не скажет, но представители сообщества будут на вас косо смотреть...

:::

[^underscore-assign]: Было еще хуже. [До версии 1.8](https://cran.r-project.org/src/base/NEWS.1) существовал оператор присваивания `_`. Да, это нижнее подчеркивание. Выглядело это [суперстранно](https://www.jumpingrivers.com/blog/r-from-the-turn-of-the-century/), хвала святому рандому, что более такого мероприятия не существует.

:::{.callout-note collapse="true"}
###### `<-`. История

Почему же всё-таки в качестве оператора присваивания стала использоваться именно стрелочка `<-`? Во всём виновна наследственность [@fay-rassignment].

Выше мы [упоминали](#r-intro-history), что R является потомком языка S. Уже в S для присваивания значения использовался символ `<-`, который ему достался в наследство от языка APL.

В APL же этот символ использовался для присваивания по двум причинам:

* оператор `=` был занят сравнение, так как `==` ещё не существовало
* на клавиатуре существовали стрелочки как отдельные клавиши, и их было просто и удобно вводить

Позднее, в 2001 году, в R была добавлена возможность использования `=` в качестве оператора присваивания, однако полностью взаимозаменяемы `=` и `<-` не стали (@wrn-assign-equal-diff).

:::

:::{#wrn-assign-equal-diff .callout-warning collapse="true"}
###### Неожиданности при путанице `<-` и `=` {#assign-equal-diff}

**Перечисленные здесь ситуации существенно затрудняют чтение кода и могут его сломать! Ознакомьтесь с возможными ситуациями и старайтесь из избегать!**

Разделение операций присваивания и передачи значения полезно с точки зрения удобочитаемости кода. Например, в таком случае:

```{r}
x <- sqrt(x = 2)
x
```

Это не значит, что функция, внутри которой написано присваивание, не сработает:

```{r}
abs(x = -5) # в аргумент x передано значение -5, вычислен модуль
x # в переменной x осталось значение из предыдущего вычисления --- x <- sqrt(x = 2)
abs(x <- -5) # в переменную x присвоено значение 5, переменная x передана в функцию модуля
x # в переменной лежит значение из предыдущей строки --- abs(x <- -5)
```

Это довольно неожиданное поведение.

Поскольку имена аргументов функций определены, может случится и другое малоприятное:

```{r, error=TRUE}
abs(y = -3) # у функции abs() нет аргумента y, есть только аргумент x
abs(y <- -3) # если сначала создать переменную y, а затем её передать в качестве аргумента x, то всё сработает
```

Если вам жизненно очень сильно необходимо создать две переменные с одинаковым значением и вы категорически не желаете делать это в две строки, можно, конечно, сделать двойное присваивание --- порядок операторов здесь будет важен:

```{r, error=TRUE}
x <- y = 10
x = y <- 10
x; y ## две короткие команды можно выполнить в одной строке, разделив их точкой в запятой
```

Никому это не показывайте и не говорите, где видели --- просто похихикайте, потому что оно весёлое:

```{r}
a <- 42 -> b
a; b
```

:::

## Орущая консоль {#r-intro-console-screams}

:::{.lab-junior}
:::

Консоль иногда будет на вас орать. Чаще всего --- осмысленно и по делу. Крики консоли делятся на три категории: ошибки, предупреждения и сообщения.


### Сообщения {#r-intro-console-messages}

:::{.lab-junior}
:::

Если консоль вывела вам **сообщение (message)** --- возрадуйтесь. R захотел с вами побеседовать, рассказать как идут дела, что вообще происходит, какие новости есть по поводу выполнения скрипта. Сообщение значит, что **всё идет хорошо**, но есть нечто, что вам как богу-программисту стоит знать о выполнении кода. Иногда в них даже предлагаются способы улучшения кода. Как правило, довольно осмысленные.

Сообщения, в целом, можно игнорировать, но всё же стоит быстренько по ним пробежаться, чтобы иметь их в виду при работе со скриптом.

SMS-ки от R бывают разного объема. Например, мы будем очень часто видеть подробное сообщение от пакета `tidyverse` при его загрузке, когда приступим к обсуждению предобработки данных (@lst-console-message-tidyverse). Другие же сообщения могут быть значительно короче (@lst-console-message-lavaan).

:::{#lst-console-message-tidyverse}
```{r console-message-tidyverse, message=TRUE}
library(tidyverse)
```

Сообщение о подключенных пакетах и особенностях процесса подключения
:::


:::{#lst-console-message-lavaan}
```{r console-message-lavaan, message=TRUE}
library(lavaan)
```

Приветственное сообщение от доброжелательного пакета
:::



### Предупреждения {#r-intro-console-warnings}

:::{.lab-junior}
:::

Иногда консоль проявляет ответственность, и решает нам сообщить, что что-то пошло не так. В это случае она шлёт нам **предупреждение (warning)**. 

Предупреждение начинается со слова `Warning`, обозначая, что оно именно предупреждение, а не простое сообщение. Если вы видите его в консоли, это значит, что **скрипт выполнился**, то есть **код сработал**, но не совсем так, как было задумано. Например, если вы предобрабатывали данные и вам вылетел ворнинг, то вы **получили результат (предобработанные данные), но нужно проверить, всё ли там так, как вы хотели**. Или если вы проводили какой-то статистический анализ и у вас возник ворнинг, то у вас **есть результаты анализа, но надо посмотреть, что там произошло, чтобы быть уверенным, что результаты корректные**.

В качестве примеров можно привести @lst-console-warning-nan, когда случилось извлечение корня из отрицательного числа, и @lst-console-warning-ggplot, когда произошло техническое изменение в пакете и некоторые аргументы теперь не поддерживаются. При этом мы видим, что в обоих случая код отбработал: в первом вернулось значение, во втором --- построен график.

:::{#lst-console-warning-nan}
```{r console-warning-nan, warning=TRUE}
sqrt(-12)
```

$\sqrt{-12}$ --- это *не число*.
:::

:::{#lst-console-warning-ggplot}
```{r console-warning-ggplot, warning=TRUE, message=TRUE}
diamonds %>% 
  ggplot(aes(price)) +
  geom_density(size = 2)
```

У линии нет размера, но есть ширина.
:::



### Ошибки {#r-intro-console-errors}

:::{.lab-junior}
:::

Если консоль вывела вам **ошибку (error)**, значит код **не был выполнен** ввиду возникновения некоторой критической ситуации, и у вас **нет результата**. Это самое критичное из возможных сообщений.

**Ошибка не является поводом идти в круглосуточный ларёк за горячительными напитками!** Первое, что с ней надо сделать --- **прочитать**!

Ошибка начинается со слова `Error`, обозначая, что она именно ошибка, а не простое сообщение и не предупреждение. Как правило, в ошибке написано, где она возникла и что пошло не так. Исходя из содержания ошибки, можно попробовать пофиксить баг. Если это не помогло, то следующий шаг --- googling текста ошибки. Скорее всего, вы не первый, кто с ней столкнулся, и на [Stack Overflow](https://stackoverflow.com/) или [Stack Exchange](https://stackexchange.com/) уже есть рекомендательные советы в количестве нескольких штук для разных операционных систем.

Мы уже видели несколько примеров ошибок выше, но вот ещё (@lst-console-error):

:::{#lst-console-error}
```{r console-error-1, error=TRUE}
sum("V", "IV", "C")
```

```{r console-error-2, error=TRUE}
ds <- read.csv("/Users/angelgardt/wlm-sdarp/data/anova/emoc.csv")
```

```{r console-error-3, error=TRUE}
diamonds %>% 
  ggplot(aes(cut, price)) +
  stat_summary(fun.data = mean_cl_boot(). geom = "pointrange")
```

Примеры ошибок в скрипте
:::

:::{.callout-tip}
###### Летс гугл ит ин рашн (ноу, плиз донт)

R поддерживает русскую локаль, то есть может выводить сообщения, предупреждения и ошибки на русском. Велик соблазн поддаться искушению и воспользоваться данной опцией в надежде, что ошибки станут понятнее, читабельнее и будут проще решаться.

Обманчиво.

* Во-первых, лексика ошибок не настолько сложна, чтобы не понять английский вариант.
* Во-вторых, если вы не поняли ошибку на английском, скорее всего, не поймете её и на русском, ибо там термины или другая специальная лексика.
* В-третьих, ошибку на русскому загуглить значительно сложнее, чем на английском.
    * Прямой копипаст английского сообщения об ошибке в 90% случаев даст вам нужный результат в первый пяти результатах поиска.

Посему, совет: **ставьте английскую версию R**.

:::




## Комментарии {#r-intro-comments}

:::{.lab-junior}
:::

Выше часто можно было встретить рядом с кодом текст после знаков `#`. Это **комментарии**.

Комментарии --- это крайне полезная вещь. Комментировать код --- жизненно необходимо. В творческо-деятельном полуночном порыве вы можете страстно увлеченно написать много кода, который вам кажется совершенно простым и очевидным. Однако зайдя в скрипт через неделю, месяц --- а может быть, уже и на утро --- вы рискуете не вспомнить ничего из изобретенного в ночи.

Комментарии начинаются с символа `#`. Всё, что следует после этого символа, игнорируется R до конца строки --- этот текст не является программным кодом и не будет выполняться. Так можно «выключить», закомментить некоторые строки скрипта, если вам они прямо сейчас не нужны. Например, в этом коде первые две строки будут выполнены, третья и четвертая --- пропущены, пятая --- выполнена (@lst-commenting):

:::{#lst-commenting}
```{r commenting}
first_var <- sqrt(14)
second_var <- 34
# abs(first_var - second_var)
# sin(first_var)
(first_var + second_var)^2
```

Закомменченные строки
:::

Что можно написать в комментариях? Ну, скажем,

* **пояснение к вычислениям** --- почему вы тут умножили на 10, а не на 100?
* **пояснение к подключаемым пакетам** --- зачем вам нужен именно этот пакет?
* **неожиданные результаты** --- здесь должно быть положительное число, а получилось отрицательное…
* **пояснение к значениям аргументов** --- почему дефолтные не подходят?
* **структуру кода** --- разделить скрипт на несколько частей

и другие мысли, которые у вас возникают по ходу предобработки и анализа данных.

Это важно. Очень. Иначе будет @fig-commenting-importance.

![Жизненная ситуация. [Источник](https://twitter.com/Loly_girl/status/1009726649263325184/photo/1)](img/r-intro/commenting-importance.png){#fig-commenting-importance}





## Цитирование R {#r-intro-citation}

:::{.lab-junior}
:::

Напоследок пара важных вещей.

На R [@r-core-team], как и на любые ресурсы, используемые при написании статьи или отчета, следует ссылаться --- цитировать в разделе References. Для этого существует удобная команда:

```{r r-citation}
citation()
```

В аутпуте есть вариант ссылки в форматах APA и BibTeх. Второй вам пригодится, если вы пишете отчеты в $\LaTeX$ или R Markdown и Quarto, первый --- в других случаях. Если вы копируете APA-цитату в текстовый редактор, добавьте курсивное форматирование на текст, заключенный между андерскорами (нижними подчеркиваниями[^underscore_term], `_`) , а сами андерскоры удалите[^underscore_md].

[^underscore_term]: Согласно правилам современного русского литературного языка, термин «нижнее подчеркивание» является плеоназмом, так как любое подчеркивание выполняется снизу. Однако такой термин используется наряду с терминами *подчерк* и *underscore*, поэтому использую его и я.

[^underscore_md]: Такой синтаксис используется в Markdown --- в частности, R Markdown.

Хорошим тоном будет сослаться и на RStudio [@rstudio-core-team]:


```{r rstudio-citation, echo=TRUE, eval=FALSE}
RStudio.Version()
```

```
$citation
To cite RStudio in publications use:

  Posit team (2024). RStudio: Integrated Development Environment for R. Posit Software,
  PBC, Boston, MA. URL http://www.posit.co/.

A BibTeX entry for LaTeX users is

  @Manual{,
    title = {RStudio: Integrated Development Environment for R},
    author = {{Posit team}},
    organization = {Posit Software, PBC},
    address = {Boston, MA},
    year = {2024},
    url = {http://www.posit.co/},
  }

$mode
[1] "desktop"

$version
[1] ‘2024.4.1.748’

$long_version
[1] "2024.04.1+748"

$release_name
[1] "Chocolate Cosmos"

```


## Обновления {#r-intro-updates}

:::{.lab-junior}
:::

R продолжает постоянно разбатываться и улучшаться, и чтобы быть в тренде стоит периодически обновляться. Большие обновления случаются достаточно редко (например, релиз `R 3.0.0` случился в апреле 2013, а `R 4.0.0` --- в апреле 2022), однако более мелкие обновления [выходят в среднем раз в три-четыре месяца](https://cran.r-project.org/bin/windows/base/old/).

Итого, можно вывести такую эвристику:

> обновляй R раз в квартал!

Узнать текущую версию R можно с помощью команды `R.version`:

```{r}
R.version
```


## Работа в R из командной строки {#r-intro-cli}

:::{.lab-guru}
:::

Если вы сверхсерьезный человек, уверены, что графический интерфейс для бедных, и общаетесь со своим комплюктером через терминал, то есть достойный вас способ работы в R прям из командной строки.

* Чтобы открыть консоль R в командной строке, выполните команду `R`.
    * Далее работайте в терминале как в консоли R.
    * Чтобы выйти из консоли R, выполните команду `q()`.
* В принципе, ничто вас не ограничивает от того, чтобы написать скрипт на R прямо в Vim.
    * Исполнить его можно из консоли R с помощью команды `source("path_to_script")` или из командной строки с помощью команды `Rscript path_to_script`.

Игрушечный пример представлен ниже (@fig-r-from-terminal).

:::{.callout-tip}
###### Где может пригодится это сакральное знание?

Честно говоря, не знаю... Однако при деплое этой книжки, который выполняет bash-скриптом, используется скрипт на R, причесывающий Google-таблицу с ответами на квизы в JSON, из которого ответы подтягиваются в JS-скрипт, выполняющий проверку квизов.

Более я такого нигде никогда не использовал.
:::

:::{.callout-note collapse="true"}
###### ТЗ к видео

Создать два скрипта на R.

**Первый**

1. Скрипт должен считывать с клавиатуры два числа (`x` и `y`).
2. Возвращать в консоль их сумму в следующем формате `This is the sum of x and y: <sum>`.
2. Скрипт должен выполняться из консоли R.

**Второй**

1. Скрипт должен выводить в командную строку количество секунд, прошедших с полуночи 1 января 1970 года по UTC (текущий timestamp) в формате `"<n> seconds passed from the midnight of Jan 1, 1970"`.
2. Скрипт должен выполняться из командной строки (через `Rscript`).
:::

```{r code-r-intro-cli, eval=FALSE}
#| code-fold: true
#| code-summary: "Код из видео"

## Первый скрипт
x <- as.numeric(readline("Enter x:" ))
y <- as.numeric(readline("Enter y:" ))
print(paste0("This is the sum of x and y: ", x + y))

## Второй скрипт
print(paste0(as.numeric(lubridate::now()), " seconds passed from the midnight of Jan 1, 1970"))

```

:::{#fig-r-from-terminal}

{{< video https://youtu.be/-rRHd8rcx44 >}}

Давайте напишем скрипт на R через Vim... Действительно... Ни одного изъяна в этом плане
:::

![Как отсюда, блин, выйти... Святой рандом, за что... [Источник](https://www.orlybooks.com/books/exiting-vim)](img/r-intro/orly-exiting-vim.png)


***

###### Session Info {#session_info .unnumbered}

```{r session-info}
sessionInfo()
```

```{=html}
<script type="text/javascript" src="./js/chapter.js"></script>
```
