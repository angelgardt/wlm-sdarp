# Git {#appendix-git}

:::{.intro}
Мы уже обсуждали [работу в проектах](r-data.qmd#r-data-rstudioprojects) и обнаружили, что это приносит ряд плюшек. Однако проекты содержат ещё один очень полезный инструмент --- **Git**. В этом приложении мы разберемся в том, что это такое, зачем оно надо, и как оно нам может существенно облегчить жизнь.
:::

## Концепция Git {#appendix-git-whatisigt}

Git --- это одна из систем контроля версий (version control system, VCS). Это, конечно, максимально понятное определение, поэтому разберемся сначала, что такое система контроля версий.



### Система контроля версий {#appendix-git-vcs}

Когда мы работаем с документами --- любыми, от кода до вордовских файлов, картинок, видео, шрифтов и др. --- мы вряд ли создаем весь документ сразу. Вспомните, как выглядит работа над статьей или курсовой/дипломной работой --- примерно так:

* мы что-то написали в начале (скажем, кусок теорчасти);
* оставили это;
* вернулись через некоторое время, внесли правки;
* добавили что-то (потому что скачали ещё статей);
* оно ещё полежало;
* снова вернулись, написали ещё (дописали теорчасть и начали описывать дизайн);
* через месяц вернулись, психанули и снесли половину теории (потому что научник сказал, что все не так);
* ...
* и где-то там за горизонтом через 100500 итераций итоговый вариант готов.

В тексте накапливались изменения --- возникали разные версии документа. Нам бы хотелось их как-то фиксировать, чтобы мы (а) могли их отслеживать, (б) при необходимости откатиться к предыдущей или вытащить из предыдущих версий какие-то части.

![Научник --- он творческий человек...](img/appendix-git/advisor-suggestions.png)

Безусловно, опытные персонажи хорошо осведомлены в творческой натуре всего научного руководителя и хранят предыдущие версии текстов --- наивный способ организации приводит к примерно такому результату (@fig-control-versions-naive).

![диплом_финал3_финалточно_самыйфинал4_итог](img/appendix-git/control-versions-naive.png){#fig-control-versions-naive}

Способ принципиально работающий, но не самый эффективный --- засоряется рабочее пространство, версии может быть трудно сопоставить друг с другом. Хотелось бы какую-то умную систему, которая бы позволяла отслеживать изменения, видеть, что и когда было удалено или добавлено, фиксировать версии документа, иметь доступ к предыдущим и возможность откатиться к ним при необходимости.

Собственно, всем этим и занимается система контроля версий. Если вы заядлый пользователя Google Docs, то наверняка знаете, что такая система там [неплохо реализована](https://support.google.com/docs/answer/190843) (@fig-google-docs-versions). 

Но это текстовые доки, а что делать с кодом?

![Контроль версий в Google Docs (`File` → `Version history` → `See version history`)](img/appendix-git/google-docs-versions.png){#fig-google-docs-versions}


:::{.callout-note}
###### Далее: Git и код

Далее мы будем говорить именно о Git, поскольку это, пожалуй, самая популярная система контроля версий. Однако, как отмечалось в самом начале, не единственная.

Кроме того, мы будем говорить преимущественно о работе с кодом, так как нас в рамках этой книжки интересует именно он. И хотя Git активно используется именно в среде программистов, для отслеживания изменений в скриптах, поместить под его контроль можно абсолютно любые файлы и папки.
:::



### Репозиторий {#appendix-git-repo}

Код, как мы знаем, не существует изолированно, а всегда связан с рабочей директорией. Этим мы научились управлять в [главе про работу с данными](r-data.qmd). Директория, в свою очередь, содержит не только код, но и файлы данных, визуализации, файлы экспорта результатов и др. Получается, чтобы эффективно следить за версиями кода, нам также нужно отслеживать и версии других файлов директории --- то есть следить за всем проектом. Для этого директорию проекта превращают в **репозиторий**.

По сути, репозиторий это всё та же директория (папка) проекта, но находящаяся под наблюдением системы контроля версий. Более ничего. Когда мы превращаем директорию проекта в git-репозиторий, в нем появляется папка `.git`, которая и будет заниматься контролем версий (@fig-div-vs-repo).

![Различия в структуре директории и репозитория](img/appendix-git/div-vs-repo.png){#fig-div-vs-repo}



### Логика Git {#appendix-git-logic}

Git работает по следующей схеме:

* есть некоторая исходная версия файлов репозитория (version 0) (@fig-git-logic-v0)
* вы внесли изменения в файлы и возникла новая версия (version 1) (@fig-git-logic-v1-0)
    * Git фиксирует состояния всех файлов в новой версии --- делает фотку репозитория в новом состоянии (@fig-git-logic-v1-1)
* если какие-то файлы не были изменены, то Git для экономии ресурсов просто ссылается в новой версии на предыдущие версии этих файлов (version 2) (@fig-git-logic-v2)
* версии связываются друг с другом ссылками --- так формируется история изменений проекта (@fig-git-logic-v3)
    * по истории можно двигаться, смотреть, что, когда и кем было изменено, и восстанавливать предыдущие версии.

:::{#fig-git-logic layout="[[1,1], [1,1], [1]]"}

![Исходное состояние репозитория](img/appendix-git/git-logic-v0.png){#fig-git-logic-v0}

![В исходное состояние внесены изменения](img/appendix-git/git-logic-v1-0.png){#fig-git-logic-v1-0}

![Зафиксировано новое состояние репозитория](img/appendix-git/git-logic-v1-1.png){#fig-git-logic-v1-1}

![Файлы B и C не были изменены в новой версии](img/appendix-git/git-logic-v2.png){#fig-git-logic-v2}

![Версии связаны друг с другом ссылками](img/appendix-git/git-logic-v3.png){#fig-git-logic-v3}

Общая логика версионирования в Git

:::



### Коммиты {#appendix-git-commits}

То, что в предыдущем разделе называлось версиями, корректнее называть **коммитами (commits)**. Во-первых, потому в Git они именно так и называются, во вторых, потому что _версии_ --- это какие-то большие ключевые состояния репозитория, включающие многие изменения. Коммиты же подразумевают небольшие изменения в репозитории, фиксируемые в процессе работы. Получается, что корректнее логику работы Git так (@fig-git-logic-commits).

![Коммиты в логике Git](img/appendix-git/git-logic-commits.png){#fig-git-logic-commits}

> **История изменений** репозитория --- это **цепочка коммитов**.

> **Если вы закоммитили** некоторое изменение, то его больше практически **невозможно потерять**.

Если коммиты формируют цепочку, то они должны ссылаться друг на друга. Собственно, выше мы говорили, что «версии» ссылаются друг на друга. Как они это делают? Весьма хитро.

[SHA-1](https://emn178.github.io/online-tools/sha1.html)


```
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum
```

```
a851751e1e14c39a78f0a4b8debf69dba0b2ae0d
```

```
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
```

```
cd36b370758a259b34845084a6cc38473cb95e27
```



