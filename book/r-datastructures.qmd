# Структуры данных {#r-datastructures}

{{< include other/_symbols.qmd >}}

```{r opts, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, error=FALSE}
knitr::opts_chunk$set(echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, error=FALSE)
```

```{r pkgs, echo=FALSE}
library(tidyverse)
theme_set(theme_bw())
library(latex2exp)
```

:::{.intro}
Мы познакомились с типами данных --- числовыми, строковыми и логическими значениями. Однако если мы подумаем о данных, которые мы собираем в исследованиях, мы обнаружим, что значения не существуют изолированно друг от друга. Например, к одному респонденту «привязаны» возраст, пол, образование, наличие или отсутствие работы, ответы на опросник, какие-нибудь экспериментальных данные и так далее в зависимости от того, что именно мы исследуем. Получается, нам нужно нечто, что будет собирать разные данные в некоторую единую структуру. Ровно этим и занимаются структуры данных, которым посвящена эта глава.
:::

Определений термину «структура данных» можно дать много. Можно сосредоточиться на технических сторонах вопроса, можно выбрать более концептуальный подход. Мы склонимся ко второму варианту и дадим достаточно для наших задач определение, хотя и весьма абстрактное.

:::{#def-datastruct}
**Структура данных** --- это способ и форма объединения однотипных и/или логически связанных данных.
:::

Что это для нас будет означать по сути? Давайте сразу с примера. Пожалуй, в подавляющем большинстве случаев мы будем иметь дело с данными, организованными в таблицу[^data-not-table] (@fig-data-exmpl). В любой таблице, как известно, есть строки и столбцы. Столбцы, как правило, соответствуют переменным, включенным в дизайн исследования и содержат данные одного типа. Таким образом, «столбчатая» организация таблиц предоставляет способ и форму объединения данных одного типа. В то же время, строки обычно соответствуют наблюдениям (экспериментальные пробы, отдельные респонденты, сочетания экспериментальных условия и др.) и объединяют данные разных типов, относящиеся к одному и тому же наблюдению. Получается, что «строчная» организация таблиц предоставляет способ объединить логически связанные друг с другом данные. Ровно об этом и говорит данное нами определение.


[^data-not-table]: О других возможностях организации данных мы скажем в следующей главе, когда будет рассматривать [форматы данных](r-data.qmd#r-data-formats).

![Пример данных](img/r-datastructures/data_exmpl.jpg){#fig-data-exmpl}

Полагаю, так или иначе, каждый читатель сталкивался с таблицами и интуитивно представляет себе, как они устроены. Это довольно удобная и логичная структура данных, поэтому хотелось бы, чтобы она была воплощена в R. Воплощение таблицы в R --- это **датафрейм** (@lst-dataframe-exmpl).

:::{#lst-dataframe-exmpl}

```{r, echo=FALSE}
data.frame(
  id = c("AARS01", "AARS01", "AARS01", "AAME02", "AAME02", "AAME02", "AARS01", "AARS01", "AARS01", "AAME02", "AAME02", "AAME02"),
  setsize = c(4, 8, 12, 4, 8, 12, 4, 8, 12, 4, 8, 12),
  type = c("dots", "dots", "dots", "dots", "dots", "dots", "tray", "tray", "tray", "tray", "tray", "tray"),
  platform = c("ios", "ios", "ios", "android", "android", "android", "ios", "ios", "ios", "android", "android", "android"),
  mean_rt = c(1.369, 1.659, 2.659, 1.124, 1.644, 1.894, 1.622, 1.961, 2.019, 1.958, 2.103, 2.249),
  accuracy = c(0.984, .966, 0.841, 0.998, 0.904, 0.812, 0.991, 0.945, 0.903, 0.975, 0.921, 0.912))
```

Датафрейм --- воплощение таблицы в R
:::

Действительно, весьма похоже на привычную таблицу (сравните [-@fig-data-exmpl] и [-@lst-dataframe-exmpl]). И хотя датафрейм выглядит довольно интуитивно, это сложная структура данных. Чтобы понять всю её мощь, необходимо начать с более простых структур, которые станут «кирпичиками» для строительства датафрейма.



## Векторы {#r-datastructures-vectors}

:::{.lab-junior}
:::

Простейшая структура данных --- это **вектор (vector)**. Предполагаю, что многие помнят со школы этот термин, которым назывался направленный отрезок. Это правда, однако мы под вектором будем понимать другую вещь. Для нас вектор --- это набор чисел. Например, мы хотим сделать вектор из трёх чисел --- $1$, $-6$ и $90.1$. Тогда это можно записать так:

$$
\pmatrix{1 \\ -6 \\ 90.1}
$$

Можно сделать вектор и из большего количества элементов --- например, из 6:

$$
\pmatrix{2 \\ 4 \\ 8 \\ 16 \\ 32 \\ 64}
$$

На самом деле, и направленный отрезок, и набор чисел --- это всего лишь два способа посмотреть на один и тот же объект, называемый вектором. Значения элементов вектора --- это просто его координаты[^vec-linal].

[^vec-linal]. Ровно так вектор [рассматривается в линейной алгебре](math-linal.qmd#math-linal-vectors).

:::{.quote .small .pers}
--- Так, подожди. Ты говоришь какие-то сомнительные вещи. Отрезок, а значит и вектор, имеет начало и конец. Тогда необходимо два набора координат, чтобы однозначно задать вектор. Ты же утверждаешь, что одного набора достаточно. Где тогда конец, а где начало? Что-то ты, автор, не договариваешь…<br>
--- Окей, давай обсудим это более детально.
:::


### Вектор как направленный отрезок и как набор чисел {#r-datastructures-vectors-arrow}

:::{.lab-junior}
:::

Давайте проследим путь от направленного отрезка к набору чисел. Возьмем некоторые направленный отрезок. Пусть координаты его начала --- $(2, 1)$, а координаты конца --- $(3, 3)$. Так мы понимали вектор с школе (@fig-vec-classic).

```{r vec-classic, echo=FALSE}
#| label: fig-vec-classic
#| fig-cap: "Вектор как направленный отрезок"

ggplot(NULL) +
  geom_segment(aes(x = 2, y = 1, xend = 3, yend = 3),
               arrow = arrow(), linewidth = 1) +
  geom_point(aes(x = c(2, 3), y = c(1, 3)), size = 2) +
  xlim(0, 5) + ylim(0, 5) +
  annotate(geom = "text", label = TeX("(2, 1)"), x = 2.35, y = 1) +
  annotate(geom = "text", label = TeX("(3, 3)"), x = 3.35, y = 3) +
  coord_fixed()
```

Однако для аналитических задач ключевыми характеристиками вектора оказываются не сами координаты, а *длина* и *направление* вектора, поэтому все векторы, имеющие одинаковые направление и длину, рассматриваются как *равные*[^vec-free].

[^vec-free]: Такие векторы называются *свободными*. Именно такие векторы [рассматриваются в линейной алгебре](math-linal.qmd#math-linal-vectors).

Так, все три вектора, изображенные на рисунке [-@fig-vec-free], являются *равными*, так как у всех трёх совпадают направление и длина.

```{r vec-free, echo=FALSE}
#| label: fig-vec-free
#| fig-cap: "Свободные векторы --- все три изображенные векторы равны между собой в рамках аналитических задач"

ggplot(NULL) +
  geom_segment(aes(x = 2, y = 1, xend = 3, yend = 3),
               arrow = arrow(), linewidth = 1) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 2),
               arrow = arrow(), linewidth = 1) +
  geom_segment(aes(x = 3, y = 1, xend = 4, yend = 3),
               arrow = arrow(), linewidth = 1) +
  geom_point(aes(x = c(2, 3), y = c(1, 3)), size = 2) +
  geom_point(aes(x = c(0, 1), y = c(0, 2)), size = 2) +
  geom_point(aes(x = c(3, 4), y = c(1, 3)), size = 2) +
  xlim(0, 5) + ylim(0, 5) +
  annotate(geom = "text", label = TeX("(2, 1)"), x = 2.35, y = 1) +
  annotate(geom = "text", label = TeX("(3, 3)"), x = 3.35, y = 3) +
  annotate(geom = "text", label = TeX("(0, 0)"), x = 0.35, y = 0) +
  annotate(geom = "text", label = TeX("(1, 2)"), x = 1.35, y = 2) +
  annotate(geom = "text", label = TeX("(3, 1)"), x = 3.35, y = 1) +
  annotate(geom = "text", label = TeX("(4, 3)"), x = 4.35, y = 3) +
  coord_fixed()
```

Если все три вектора для нас равны, но нам всё равно, какой из них рассматривать. Договоримся, что все векторы у нас начинаются из точки $(0, 0)$ (начала координат), так как это избавит нас от необходимости учитывать координаты начала вектора --- они всегда будут $(0, 0)$. Тогда исходный вектор с началом в $(2, 1)$ и концом в $(3, 3)$ примет такой вид (@fig-vec-start):

```{r vec-start, echo=FALSE}
#| label: fig-vec-start
#| fig-cap: "Вектор, однозначно заданный координатами конца отрезка"

ggplot(NULL) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 2),
               arrow = arrow(), linewidth = 1) +
  geom_point(aes(x = 1, y = 2), size = 2) +
  xlim(0, 5) + ylim(0, 5) +
  annotate(geom = "text", label = TeX("(1, 2)"), x = 1.35, y = 2) +
  coord_fixed()
```

Таким образом, теперь любой вектор однозначно задаётся координатами своего конца. Получается, мы можем просто записать $(1, 2)$, или же в форме, принятой в математике для векторов --- $\pmatrix{1 \\ 2}$.

Вот и вся магия.

То есть теперь для нас вектор равносилен набору координат его конца. Конец вектора --- это точка плоскости, которая однозначно описывается двумя координатами. Приведём ещё несколько примеров. Пусть у нас есть три вектора:

$$
\pmatrix{1 \\ 0.5}, \quad \pmatrix{2 \\ 3}, \quad \pmatrix{-2.5 \\ -2.5}
$$

Изобразить их можно следующим образом (@fig-vec-same):

:::{#fig-vec-same}

```{r vec-same, echo=FALSE}
ggplot(NULL) +
  geom_segment(aes(x = 0, y = 0, 
                   xend = c(1, 2, -2.5), 
                   yend = c(.5, 3, -2.5)),
               arrow = arrow(), linewidth = 1) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  geom_vline(xintercept = 0, linetype = "dotted") +
  annotate(geom = "text", 
           label = TeX(c("$(1, 0.5)$", "$(2, 3)$", "$(-2.5, -2.5)$")), 
           x = c(1.5, 2.5, -2.5), 
           y = c(.5, 3, -2.7)) +
  xlim(-3, 3) + ylim(-3, 3) +
  coord_fixed()
```

Векторы $\pmatrix{1 \\ 0.5}$, $\pmatrix{2 \\ 3}$ и $\pmatrix{-2.5 \\ -2.5}$
:::

Здесь важно отметить, что значения в векторе идут в том же порядке, что и координаты конца отрезка --- сначала $x$, потом $y$. Векторы $\pmatrix{1 \\ 2}$ и $\pmatrix{2 \\ 1}$ --- это разные векторы, так как у них различается направление, хотя и совпадает длина (@fig-vec-order-coords).

:::{#fig-vec-order-coords}

```{r vec-order-coords, echo=FALSE}
ggplot(NULL) +
  geom_segment(aes(x = 0, y = 0, 
                   xend = c(1, 2), 
                   yend = c(2, 1)),
               arrow = arrow(), linewidth = 1) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  geom_vline(xintercept = 0, linetype = "dotted") +
  annotate(geom = "text", 
           label = TeX(c("$(1, 2)$", "$(2, 1)$")), 
           x = c(1, 2), 
           y = c(2.3, 1.3)) +
  xlim(-3, 3) + ylim(-3, 3) +
  coord_fixed()
```

Векторы $\pmatrix{1 \\ 2}$ и $\pmatrix{2 \\ 1}$
:::

Пока мы живём на плоскости, то всё легко визуализировать --- есть две координаты, значит в векторах будет по два элемента. Однако в самом начале мы сказали, что в векторе может быть и больше элементов. Принципиально здесь ничего не меняется, только теперь это будут координаты в трёх-, четырёх-, шестимерном пространстве. Отрисовать и представить себе это весьма трудно, однако математика такого не запрещает.


### Вектор как структура данных {#r-datastructures-vectors-datastruct}

:::{.lab-junior}
:::

Вернёмся к вектору как структуре данных, ведь это наша главная цель. Опираясь на рассмотренное выше геометрическое представление, можно дать следующее определение:

:::{#def-vector}
**Вектор** --- это упорядоченный набор элементов одного типа.
:::

Почему такое определение соответствует геометрическому представлению? Давайте по пунктам:

* в векторе есть определённые *элементы*
    * в примерах выше это были числа
* их несколько, поэтому это *набор*
    * в примерах выше было минимум два
* все элементы являются объектами *одного и того же типа данных*
    * в примерах выше в векторе могли быть только числа
* элементы *упорядочены*
    * в примерах выше мы видели, что $\pmatrix{1 \\ 2} \neq \pmatrix{2 \\ 1}$

Вот и получается такая структура. У вектора как структуры данных нет ограничения на тип данных --- вектор может быть числовым, текстовым или логическим. Важно, чтобы внутри него все элементы были либо текстовыми, либо числовыми, либо логическими.

:::{.callout-note appearance="simple" collapse="true"}
###### Упорядоченный ≠ Отсортированный

Слово «упорядоченный» может вводить в некоторое заблуждение, так как по смыслу тесно связано со словом «отсортированный», однако есть существенное различие.

* Если набор элементов **упорядочен**, значит мы знаем, какой идёт первым, какой --- вторым, какой --- третьим, и так далее.
    * Вовсе не обязательно, что первый будет наименьшим, а последний --- наибольшим.
* Если набор элементов **отсортирован**, значит он *упорядочен по возрастанию или по убыванию*.
    * В случае сортировки по возрастанию первый элемент наименьший, второй --- больше первого, но меньше третьего, третий --- больше второго, но меньше четвертого, и так далее. Последний элемент будет наибольшем.
    * В случае сортировки по убыванию всё наоборот.

:::

### Создание векторов {#r-datastructures-vectors-creation}

:::{.lab-junior}
:::

Что-то мы заболтались --- давайте уже попробует что-нибудь покодить. Сперва научимся создавать векторы. Вектор можно создать из произвольных элементов с помощью функции `c()` (от _**c**oncatenate_ или _**c**ombine_):

:::{#lst-vec-creation}
```{r vec-creation}
v_num <- c(1, 6, -34, 7.7, 0, 0.36) # числовой вектор
v_char <- c("Москва", "Санкт-Петербург", "Нижний Новгород", "Пермь") # текстовый вектор
v_log <- c(TRUE, FALSE, TRUE, TRUE, FALSE) # логический вектор
```

Создание векторов
:::

:::{.callout-caution}
###### Великий рофл случая

Так случилось, что латинская `c` и русская `с` выглядят идентично и находятся на одной и той же клавише клавиатуры. Из-за этого часто возникает следующая ошибка:

```{r c-error, error=TRUE}
v_num <- с(1, 6, -34, 7.7, 0, 0.36)
```

Код выглядит совершенно корректно, однако R сообщает, что не нашёл функцию `с()`. Это значит, что вы забыли переключить раскладку клавиатуры, когда писали соответствующую команду. Всё, что нужно сделать, сменить раскладку и исправить название функции.
:::

Итак, мы создали три вектора разных типов --- числовой `v_num`, тестовый `v_char` и логический `v_log`. Можно убедиться, что они соответствуют своим типам с помощью уже знакомой нам функции `class()`:

:::{#lst-vec-types-print}
```{r vec-types-print}
class(v_num)
class(v_char)
class(v_log)
```

Узнать тип вектора
:::

Кроме того, можно вывести содержимое вектора. Для этого нужно просто написать название переменной, в которую был сохранён вектор --- значения, сложенные в него, будут напечатаны в консоли:

:::{#lst-vec-print}
```{r}
v_num
v_char
v_log
```

Вывести содержимое вектора в консоль
:::


:::{#lst-vec-lenght}
```{r}
length(v_num)
length(v_char)
length(v_log)
```

Узнать количество элементов в векторе (длину вектора)
:::

:::{.callout-important}
###### В R нет скаляров

:::{.quote .small .pers}
--- Что-о-о-о? Но ведь числа? У нас были числа…<br>
--- Были. Но скаляров всё равно нет.
:::

Во многих языках программирования существует разделения на *скаляры* и *векторы*. Скаляры --- это величины

:::


### Генерация числовых последовательностей {#r-datatypes-vectors-sequencies}

:::{.lab-junior}
:::




### Индексация векторов {#r-datastructures-vectors-indexing}

Из вектора можно вытащить его элемент:

```{r}
v_char[2] # по номеру
v_num[v_num > 5] # по условию
```


### Векторизация {#r-datastructures-vectors-vestorization}

Для того, чтобы выполнить операцию на всем векторе поэлементно, не нужно перебирать его элементы.

```{r}
vec <- 1:4
vec - 1
vec^2
sqrt(vec)
```


### Recycling {#r-datastructures-vectors-recycling}

Если мы будем, например, складывать два вектора разной длины, то более короткий зациклится.

```{r}
vec1 <- 1:10
vec2 <- 1:2

vec1
vec2
vec1 + vec2
```



## `factor` {#r-datastructures-factors}

:::{.lab-junior}
:::

Бывают такие переменные, которые группируют наши данные. Например,

- город проживания (`Москва`, `Санкт-Петербург`, `Казань`, `Екатеринбург`)
- уровень образования (`бакалавриат`, `специалитет`, `магистратура`, `аспирантура`)
- экспериментальная группа (`group1`, `group2`, `control`)
- и др.

Обычно они текстовые. Для них был придуман тип данных `factor`, чтобы их было дешевле хранить. Однако большинство современных пакетов сами могут решить, когда надо текст перевести в фактор.

`Ordered factor` (**упорядоченный фактор**) --- тип данных, который позволяет задать порядок групп. Например,

- уровень образования: `bachelor` < `master` < `phd` < `postdoc`
- сложность экспериментальной задачи: `easy` < `medium` < `hard`
- и др.

Вот упорядоченный фактор нам время от времени может понадобиться --- например, для создания визуализаций или в некоторых статистических моделях.

```{r}
typeof(factor("x"))
is.integer(factor("x"))
is.numeric(factor("x"))
```



## Матрицы {#r-datastructures-matrices}

:::{.lab-junior}
:::

Если мы желаем приблизиться к датафрейму, то одного ряда элементов нам недостаточно --- надо выходить во второе измерение! Поэтому уложим вектор в матрицу:

<center>
<figure>
<img src="pics/vec-to-mat.png">
<figcaption>Варианты преобразования вектора в матрицу</figcaption>
</figure>
</center>

Или вот еще разные варианты:

```{r}
v <- 1:12
m1 <- matrix(v, nrow = 3)
m1

m2 <- matrix(v, nrow = 4)
m2

m3 <- matrix(v, nrow = 3, byrow = TRUE)
m3

m4 <- matrix(v, nrow = 4, byrow = TRUE)
m4
```


### Индексация матриц {#r-datastructures-matrices-indexing}

Из матрицы можно вытащить её элементы:

```{r}
m1
m1[2, 3] # отдельный элемент
m1[1, ] # целую строку
m1[, 4] # целый столбец
m1[1:2, 2:4] # часть матрицы
```


## Массивы {#r-datastructures-arrays}

:::{.lab-middle}
:::

- Вектор --- одномерный массив.
- Матрица --- двумерный массив.
- **Массивы** --- структуры, которые объединяют данные только одного типа.

```{r}
c(2, TRUE)
c(2, TRUE, "word")
```

При объединении разных типов данных в одном массиве происходит **приведение типов (coercion)** по следующей иерархии:

<center>
`logical` → `integer` → `numeric` → `complex` → `character`
</center>

Это нам осложняет жизнь, так как мы бы хотели объединять данные разных типов в одну структуру.


## Списки {#r-datastructures-lists}

:::{.lab-junior}
:::

Списки позволяют объединять массивы различных типов данных, чем делают нашу жизнь значительно приятнее.

<center>
<figure>
<img src="pics/list-structure.png">
<figcaption>Схема внутренней структуры списка</figcaption>
</figure>
</center>

Например, так:

```{r}
l <- list(v1 = v_num,
          v2 = v_char,
          m1 = m1,
          ls = list(v = v,
                    m = m3))
l
```


### Индексация списков {#r-datastructures-lists-indexing}

```{r}
l[1] # по номеру элемента, возвращается список
l[[1]] # по номеру элемента, возвращается массив
l$ls # по названию элемента
l$ls$m # можно идти многоуровнево
```


## Датафреймы {#r-datastructures-dataframes}

:::{.lab-junior}
:::

- возьмем список
- потребуем, чтобы его элементами были **векторы**
- потребуем, чтобы эти векторы были **одинаковой длины**
- расположим их «вертикально»

<center>
<figure>
<img src="pics/list-vs-df.png">
<figcaption>Структура списка и датафрейма</figcaption>
</figure>
</center>


### Индексация датафрейма {#r-datastructures-dataframes-indexing}

Для примера возьмем датафрейм про бриллианты:

```{r, echo=FALSE}
head(ggplot2::diamonds) -> diam
```

```{r}
diam
```

Датафрейм наследует свойства списка и матрицы, что делает его невероятно гибким в обращении и крайне удобным в работе:

```{r}
diam$carat # вытащить столбец
diam[diam$price > 330, ] # отобрать строки по условию
diam[, c(2:3, 7)] # вытащить столбцы по номерам
diam[1:4, c("carat", "price")] # вытащить отдельные строки по номерам и столбцы по названиям
```





```{=html}
<script type="text/javascript" src="./js/chapter.js"></script>
```
