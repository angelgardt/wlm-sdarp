# Структуры данных {#r-datastructures}

{{< include other/_symbols.qmd >}}

```{r opts, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, error=FALSE}
knitr::opts_chunk$set(echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, error=FALSE)
```

```{r pkgs, echo=FALSE}
library(tidyverse)
theme_set(theme_bw())
library(latex2exp)
```

:::{.intro}
Вступление
:::


**Структура данных** --- это способ и форма объединения однотипных и/или логически связанных данных.

<center>
<figure>
<img src="pics/tidy-2.jpg">
<figcaption>Пример данных</figcaption>
</figure>
</center>


### Датафрейм

Воплощение привычной нам «таблицы» в R.

```{r, echo=FALSE}
head(ggplot2::diamonds)
```

Это сложная структура данных. Чтобы понять всю её мощь, необходимо начать с более простых.

### Векторы

Вектор --- это набор чисел.

$$
\pmatrix{1 & 4 & 36 & -8 & 90.1 & -14.5}
$$


Если это утверждение вызывает у вас внутренний протест, давай проследим пусть от направленного отрезка в набору чисел.


Возьмем направленный отрезок --- вектор:

```{r vec-classic, echo=FALSE}
ggplot(NULL) +
  geom_segment(aes(x = 2, y = 1, xend = 3, yend = 3),
               arrow = arrow(), linewidth = 1) +
  geom_point(aes(x = c(2, 3), y = c(1, 3)), size = 2) +
  xlim(0, 5) + ylim(0, 5) +
  annotate(geom = "text", label = TeX("(2, 1)"), x = 2.5, y = 1) +
  annotate(geom = "text", label = TeX("(3, 3)"), x = 3.5, y = 3) +
  coord_fixed()
```

Именно так мы понимали вектор в школе. Договоримся, что все векторы у нас начинаются из точки $(0, 0)$:

```{r vec-free, echo=FALSE}
ggplot(NULL) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 2),
               arrow = arrow(), linewidth = 1) +
  geom_point(aes(x = 1, y = 2), size = 2) +
  xlim(0, 5) + ylim(0, 5) +
  annotate(geom = "text", label = TeX("(1, 2)"), x = 1.5, y = 2) +
  coord_fixed()
```

Если теперь у нас все вектора начинаются из начал координат, то мы можем полностью описать вектор только координатами его конца. Поэтому уберем вектор:

```{r vec-remove-vector, echo=FALSE}
ggplot(NULL) +
  # geom_segment(aes(x = 0, y = 0, xend = 1, yend = 2),
  #              arrow = arrow(), linewidth = 1) +
  geom_point(aes(x = 1, y = 2), size = 2) +
  xlim(0, 5) + ylim(0, 5) +
  annotate(geom = "text", label = TeX("(1, 2)"), x = 1.5, y = 2) +
  coord_fixed()
```

То есть для нас теперь вектор равносилен точке на плоскости. А точка однозначно описывается двумя координатами. Получается, можно просто записать:

$$
\pmatrix{1 & 2}
$$


Получается, что это одно и то же:

$$
\pmatrix{1 & 0.5}, \quad \pmatrix{2 & 3}, \quad \pmatrix{4.2 & -3.5}
$$

```{r vec-same, echo=FALSE}
ggplot(NULL) +
  geom_segment(aes(x = 0, y = 0, 
                   xend = c(1, 2, 4.2), 
                   yend = c(.5, 3, -3.5)),
               arrow = arrow(), linewidth = 1) +
  xlim(0, 5) + ylim(-5, 5) +
  annotate(geom = "text", label = TeX(c("$(1, 0.5)$", "$(2, 3)$", "$(4.2, -3.5)$")), 
           x = c(1.3, 2.3, 4.5), 
           y = c(.5, 3, -3.5))
```


Теперь обобщим вектор на более общие случаи:

> Вектор --- это набор некоторого колчиества элементов одного типа.

```{r vec-types}
v_num <- c(1, 6, -34, 7.7) # числовой вектор
v_char <- c("Москва", "Санкт-Петербург", "Нижний Новгород", "Пермь") # текстовый вектор
v_log <- c(TRUE, FALSE, TRUE, TRUE) # логический вектор
```

```{r vec-typer-print}
class(v_num)
v_num
class(v_char)
v_char
class(v_log)
v_log
```


#### Индексация векторов

Из вектора можно вытащить его элемент:

```{r}
v_char[2] # по номеру
v_num[v_num > 5] # по условию
```


#### Векторизация

Для того, чтобы выполнить операцию на всем векторе поэлементно, не нужно перебирать его элементы.

```{r}
vec <- 1:4
vec - 1
vec^2
sqrt(vec)
```


#### Recycling

Если мы будем, например, складывать два вектора разной длины, то более короткий зациклится.

```{r}
vec1 <- 1:10
vec2 <- 1:2

vec1
vec2
vec1 + vec2
```



## `factor`

:::{.lab-junior}
:::

Бывают такие переменные, которые группируют наши данные. Например,

- город проживания (`Москва`, `Санкт-Петербург`, `Казань`, `Екатеринбург`)
- уровень образования (`бакалавриат`, `специалитет`, `магистратура`, `аспирантура`)
- экспериментальная группа (`group1`, `group2`, `control`)
- и др.

Обычно они текстовые. Для них был придуман тип данных `factor`, чтобы их было дешевле хранить. Однако большинство современных пакетов сами могут решить, когда надо текст перевести в фактор.

`Ordered factor` (**упорядоченный фактор**) --- тип данных, который позволяет задать порядок групп. Например,

- уровень образования: `bachelor` < `master` < `phd` < `postdoc`
- сложность экспериментальной задачи: `easy` < `medium` < `hard`
- и др.

Вот упорядоченный фактор нам время от времени может понадобиться --- например, для создания визуализаций или в некоторых статистических моделях.

```{r}
typeof(factor("x"))
is.integer(factor("x"))
is.numeric(factor("x"))
```



## Матрицы

Если мы желаем приблизиться к датафрейму, то одного ряда элементов нам недостаточно --- надо выходить во второе измерение! Поэтому уложим вектор в матрицу:

<center>
<figure>
<img src="pics/vec-to-mat.png">
<figcaption>Варианты преобразования вектора в матрицу</figcaption>
</figure>
</center>

Или вот еще разные варианты:

```{r}
v <- 1:12
m1 <- matrix(v, nrow = 3)
m1

m2 <- matrix(v, nrow = 4)
m2

m3 <- matrix(v, nrow = 3, byrow = TRUE)
m3

m4 <- matrix(v, nrow = 4, byrow = TRUE)
m4
```


### Индексация матриц

Из матрицы можно вытащить её элементы:

```{r}
m1
m1[2, 3] # отдельный элемент
m1[1, ] # целую строку
m1[, 4] # целый столбец
m1[1:2, 2:4] # часть матрицы
```


## Массивы

- Вектор --- одномерный массив.
- Матрица --- двумерный массив.
- **Массивы** --- структуры, которые объединяют данные только одного типа.

```{r}
c(2, TRUE)
c(2, TRUE, "word")
```

При объединении разных типов данных в одном массиве происходит **приведение типов (coercion)** по следующей иерархии:

<center>
`logical` → `integer` → `numeric` → `complex` → `character`
</center>

Это нам осложняет жизнь, так как мы бы хотели объединять данные разных типов в одну структуру.


## Списки

Списки позволяют объединять массивы различных типов данных, чем делают нашу жизнь значительно приятнее.

<center>
<figure>
<img src="pics/list-structure.png">
<figcaption>Схема внутренней структуры списка</figcaption>
</figure>
</center>

Например, так:

```{r}
l <- list(v1 = v_num,
          v2 = v_char,
          m1 = m1,
          ls = list(v = v,
                    m = m3))
l
```


### Индексация списков

```{r}
l[1] # по номеру элемента, возвращается список
l[[1]] # по номеру элемента, возвращается массив
l$ls # по названию элемента
l$ls$m # можно идти многоуровнево
```


## Собираем датафрейм

- возьмем список
- потребуем, чтобы его элементами были **векторы**
- потребуем, чтобы эти векторы были **одинаковой длины**
- расположим их «вертикально»

<center>
<figure>
<img src="pics/list-vs-df.png">
<figcaption>Структура списка и датафрейма</figcaption>
</figure>
</center>


### Индексация датафрейма

Для примера возьмем датафрейм про бриллианты:

```{r, echo=FALSE}
head(ggplot2::diamonds) -> diam
```

```{r}
diam
```

Датафрейм наследует свойства списка и матрицы, что делает его невероятно гибким в обращении и крайне удобным в работе:

```{r}
diam$carat # вытащить столбец
diam[diam$price > 330, ] # отобрать строки по условию
diam[, c(2:3, 7)] # вытащить столбцы по номерам
diam[1:4, c("carat", "price")] # вытащить отдельные строки по номерам и столбцы по названиям
```





```{=html}
<script type="text/javascript" src="./js/chapter.js"></script>
```
