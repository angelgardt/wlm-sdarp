# Типы данных {#r-datatypes}

{{< include other/_symbols.qmd >}}

```{r opts, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, error=FALSE}
knitr::opts_chunk$set(echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, error=FALSE)
```

```{r pkgs, echo=FALSE}
library(tidyverse)
theme_set(theme_bw())
library(rvest)
```

:::{.intro}
В прошлой главе мы познакомились с самыми базовыми основами работы в R. В этой и следующей главах мы разберемся в фундаментальных сущностях языка --- типах и структурах данных. Ведь в итоге мы хотим освоить R для работы с данными --- давайте разберемся, что в этих данных бывает.

Мы уже неизбежно столкнулись с данными --- как минимум в прошлой главе у нас были числа, над которыми мы выполняли математические операции, а также нечто, имеющее значения `TRUE` и `FALSE`, получавшееся после сравнений. Что ж, займемся структурированием и расширением этого эмпирического опыта.
:::

## Концепт «тип данных» {#r-datatypes-concept}

:::{.lab-junior}
:::

Что вообще такое тип данных? Определение можно дать много разных, но все они сводятся к следующей идее:

:::{#def-datatype}
**Тип данных** --- это характеристика данных, которая определяет **допустимые значения**, которые могут принимать данные этого типа, и **допустимые операции** над данными этого типа [@iso24765-2017].
:::

:::{.quote .small .pers}
--- Это, конечно, хорошо. Но что это означает на деле? <br>
--- Сейчас разберемся, рассмотрев типы данных в R.
:::

Стоит отметить, что в разных языках программирования выделяются разные типы данных, а в сущности одни и те же типы могут называться по-разному. Мы, разумеется, будем рассматривать типы данных языка R, ибо изучаем именно его, однако сопоставить их с типами данных других языков программирования на составляет труда.



## Числа {#r-datatypes-numbers}

:::{.lab-junior}
:::

Первое, с чем должно быть возможно работать, это, конечно же, числа. Для них в R предусмотрен тип `numeric`.


### `numeric` {#r-datatypes-numeric}

:::{.lab-junior}
:::

Как нам удостовериться в очевидном факте, что `2` --- это число? Для этого в R существует функция `class()`, которая позволяет узнать тип данных конкретного объекта.

Узнаем, действительно ли `2` является числом:

:::{#lst-class-of-2}
```{r class-of-2}
class(2)
```

Работа функции `class()`
:::

Аналогично, можем убедиться, что `3.14` также является числом:

```{r class-of-3-14}
class(3.14)
```

Функция `class()` также успешно справится и с переменными. Например,

```{r class-var}
x <- cos(4)
x
class(x)
```


С числами, как и следовало ожидать, **можно выполнять все математические операции** --- складывать, вычитать, делить, умножать и т. д. --- а также **вызывать на них математические функции** --- корни, логарифмы, экспоненты, синусы и др. Собственно, этим мы занимались в предыдущей главе. Давайте вспомним.

Создадим три числовые переменные `x`, `y` и `z` и поразвлекаемся.

```{r numfun-vars}
x <- 3.5
y <- 5.67
z <- -12.3
```

Уже знакомые нам математические операции:

:::{#lst-numfun-arithm}

```{r numfun-arithm}
x + y # сложение
x - y # вычитание
x * y # умножение
x / y # деление
x %/% y # целочисленное деление
y %/% x # целочисленное деление
y %% x # взятие остатка от деления
x ^ y # возведение в степень
```

Математические операции с числовыми переменными
:::

Знакомые и новые математические функции:

:::{#lst-numfun-funcs}

```{r numfun-funcs}
log(x, y) # логарифм
sqrt(x) # квадратный корень
sin(x); cos(x); tan(x)  # тригонометрия
exp(x) # экспонента, e^x
abs(z) # модуль
sum(x, y, z) # сумма нескольких переменных
round(y, 1) # округлить до заданного числа знаков после точки
ceiling(z) # округлить до ближайшего целого вверх
floor(z) # округлить до ближайшего целого вниз
```

Математические функции с числовыми переменными
:::

В общем, арсенал вполне приличный.



### `integer` {#r-datatypes-integer}

:::{.lab-middle}
:::

Дотошный читатель, имевший опыт работы с другими языками программирования, мог озадачиться, увидев @lst-class-of-2. Отчасти справедливо, так как $2$ --- это целое число, а практически во всех языках программирования под целые числа выделяется отдельный тип данных[^datatype-integer].

В R такой тип данных тоже есть, и называется он классически `integer`. Однако **по умолчанию все числа рассматриваются в R как `numeric`.** Иначе говоря, запись `2` рассматривается как `2.0`. Это довольно удобно для аналитических задач, где у нас целые числа появляются не то чтобы часто.

[^datatype-integer]: Это связано с различиями в способе хранения целых чисел и чисел с плавающей точкой. Подробнее см. [приложение](appendix-numbers-iron.qmd).

Тем не менее, создать целое число всё же можно --- для этого надо указать, что нам нужно именно целое число с помощью буквы `L` сразу после числа[^integer-L]. Например, чтобы положить в переменную целое число $2$, нужно записать так:

```{r integer-2}
y <- 2L
```

[^integer-L]: Литерал `L` обозначает, что это `long integer` [@wickham-advr-2019]. Подробнее см. [приложение](appendix-numbers-iron.qmd).

Мы можем удостовериться, что `y` --- это переменная целочисленного типа, то есть `integer`:

```{r class-integer}
class(y)
```

Едва ли вам придется когда-либо вручную прописывать, что необходимы именно целочисленные значения переменной. Однако вы с ними можете столкнуться, например, при работе с циклами --- они там появляются сами, и если не знать, что это такое, можно сильно удивиться числу, например, `100L`.

Для целых чисел выполняются те же операции, что и для чисел типа `numeric`:

:::{#lst-numfun-integer}

```{r numfun-integer}
a <- 24L
b <- 12L
c <- -7L

a + b # сложение
a - b # вычитание
a * b # умножение
a / b # деление
a %/% b # целочисленное деление
a %/% c # целочисленное деление
a %% c # взятие остатка от деления
a ^ b # возведение в степень
a ^ c # возведение в степень

log(a, b) # логарифм
sqrt(a) # квадратный корень
sin(a); cos(b); tan(c)  # тригонометрия
exp(a) # экспонента, e^x
abs(c) # модуль
sum(a, b, c) # сумма нескольких переменных
```

Математические операции и функции на целочисленных переменных
:::

Функции округления бессмысленны, так как числа изначально целые, то есть не имеют дробной части.

:::{#exr-num-int-arithm}
Выясните, существует ли разница между `2 + 3` и `2L + 3L`.
:::

::::{.solution}

:::{.cell}
Разница существует, хотя и довольно незначительная:

```{r}
class(2 + 3)
class(2L + 3L)
```
:::
::::



## Логические значения {#r-datatypes-logical}

:::{.lab-junior}
:::

Помимо чисел в прошлой главе мы видели два особенных значения --- `TRUE` и `FALSE`.

:::{.quote .small .pers}
--- Это явно не числа. По крайне мере, не похожи на них. <br>
--- Всё так. Это данные итого типа.
:::

Мы столкнулись с логическим типом данных, именуемым в R `logical`[^logical-boolean]. У этого типа данных всего два возможных значения --- те самые `TRUE` и `FALSE`. Первый обозначает «истину», второй --- «ложь»[^binary-logic]. Это довольно справедливо, если учесть, что мы их получали как результат сравнения двух чисел:

```{r comparison-bool}
2 == 2 # довольно трудно спорить с тем, что это утверждение истинно
1 != 1 # весьма непросто возразить тому, что это утверждение ложно
```

[^logical-boolean]: Другое название этого типа --- `boolean`. В данному случае мы имеем дело с полными синонимами.

[^binary-logic]: Вариантов, кроме «истина» и «ложь», не существует, так как мы имеем дело с *двузначной логикой*. Вообще это не единственный вариант построить логическую систему, однако других мы касаться в этой книжке не будем.


:::{.callout-warning}
###### Логические константы

Значения `TRUE` и `FALSE` --- это **зарезервированные константы**. Это значит, что они защищены от перезаписи --- их значение зафиксировано и не может измениться.

```{r assign-true, error=TRUE}
TRUE <- 2
FALSE <- -50 + 13
TRUE <- FALSE
```
:::

> Мы видим, что у логического типа данных всего два возможных значения, в то время как у числового типа данных их было бесконечно много. Это и есть «допустимые значения», упомянутые в определении [-@def-datatype].


::::{.callout-important}
###### Case sensitivity

R чувствителен к регистру (case sensitive), поэтому `TRUE`, `true` и `True` --- это разные сущности!

:::{#lst-case-sensitivity}
```{r case-sens-logical, error=TRUE}
class(TRUE); class(FALSE)
class(True); class(False)
class(true); class(false)
```

Чувствительность к регистру в логических константах
:::
::::

Мы уже знакомы с **операторами сравнения** (`==`, `!=`, `<`, `>`, `<=`, `>=`), результатом действия которых являются логические значения. Однако существуют собственно **логические операторы**, которые работают только с логическими значениями.


### Логические операторы {#r-datatypes-logic-operators}

:::{.lab-junior}
:::

Существует всего три основных оператора --- НЕ (`!`), И (`&`) и ИЛИ (`|`). Вообще они к нам пришли из формальной логики и не являются чем-то специфичным для программирования и тем более для R. Соответственно, и работают они так, как им предписывают законы формальной логики[^formal-logic].

[^formal-logic]: Под знакомство с этой наукой выделена [соответствующая глава](math-logic.qmd).

Однако даже если вы с этой отраслью знаний не знакомы, вполне можно понять, как эти операторы работают, просто посмотрев на них в деле.


#### НЕ (`!`) {#r-datatypes-logic-not}

:::{.lab-junior}
:::

НЕ --- оператор отрицания. Обозначается с помощью восклицательного знака --- `!`. Он превращает «истину» в «ложь», а «ложь» --- в «истину»:

:::{#lst-logical-not}
```{r logic-not}
!TRUE
!FALSE
```

Логическое отрицание в R
:::

Всё.

Ну, ладно. Можно заметить ещё кое-что: это *унарный оператор*, то есть он работает только с *одним* объектом.

Теперь точно всё.


#### И (`&`) {#r-datatypes-logic-and}

:::{.lab-junior}
:::

Тут уже интереснее: И --- это *бинарный* оператор, то есть он работает с двумя объектами. Если объекта всего два и у каждого может быть одно и двух значений --- либо «истина», либо «ложь» --- то всего комбинаций может быть четыре. Посмотрим, что возвращает оператор в каждом из случаев:

:::{#lst-logical-and}
```{r logic-and}
TRUE & TRUE
TRUE & FALSE
FALSE & TRUE
FALSE & FALSE
```

Логическое И в R
:::

Закономерность проста: логическое И возвращает «истину» (`TRUE`) только в том случае, если по обеим сторонам от него стоит «истина». Если же хотя бы с одной из сторон «ложь», то и в результате будет «ложь».

:::{.quote .small .pers}
--- Это очевидно, потому что это конъюнкция... <br>
--- Всё так. Но вообще-то неискушенный в формальной логике читатель об этом знать не обязан. Попозже его с этим познакомим.
:::


#### ИЛИ (`|`) {#r-datatypes-logic-or}

:::{.lab-junior}
:::

ИЛИ --- это тоже бинарный оператор. Посмотрим, чем он отличается от И:

:::{#lst-logical-or}
```{r logic-or}
TRUE | TRUE
TRUE | FALSE
FALSE | TRUE
FALSE | FALSE
```

Логическое ИЛИ в R
:::

Здесь ситуация в каком-то смысле противоположная --- ИЛИ возвращает «ложь» только в том случае, если по обеим сторонам от него стоит «ложь». Если же *хотя бы с одной* стороны есть «истина», то и в результате будет «истина».

:::{.quote .small .pers}
--- Естественно, потому что это дизъюнкция. <br>
--- Верно, но прекрати уже пугать читателя непонятными словами, пожалуйста...
:::


#### ИЛИ-ИЛИ (`xor()`) {#r-datatypes-logic-not}

:::{.lab-senior}
:::

Кроме трех упомянутых выше и наиболее популярных операторов, есть ещё один --- ИЛИ-ИЛИ. Если вы шарите за логику или имели дело, например, с низкоуровневым программированием, то это знакомый вам XOR. Он реализован в R как функция:

:::{#lst-logical-xor}
```{r logic-xor}
xor(TRUE, TRUE)
xor(TRUE, FALSE)
xor(FALSE, TRUE)
xor(FALSE, FALSE)
```

Исключающее ИЛИ в R
:::

Он возвращает «истину» только тогда, когда *ровно с одной стороны* от него стоит «истина». Если же по обеим сторонам от него стоит «истина» или же с обеих сторон стоит «ложь», он вернет «ложь».



### Логические операции в практике {#r-datatypes-logic-in-pract}

:::{.lab-junior}
:::

Конечно же, в реальной ситуации мы не будет проверять, что `2 == 2` или выяснять, что `TRUE & FALSE` --- это `FALSE` в явном виде. Мы будем активно использовать эти операции в предобработке данных.

Скажем, у вас есть большая таблица с данными исследования, из которой вам нужно отобрать только молодежь. Тогда будет использоваться примерно такое условие (`age` --- столбец с возрастом):

```
age >=18 & age <= 35
```

Или же у вас данные эксперимента и вам надо удалить статистические выбросы по времени реакции. Вы создали колонку `is_outlier`, в которой для каждого наблюдения указано, является ли оно выбросом (`TRUE`) или не является (`FALSE`). Тогда в условии отбора наблюдений мы напишем:

```
!is_outlier
```

Это пока что просто примеры, свидетельствующие о том, что логические операции нам нужны. В следующей главе мы познакомимся со структурами данных, и уже сможем немного попрактиковаться.

Пока же нам надо доделать фундамент. Продолжим знакомиться с типами данных.


:::{.callout-caution}
###### Аналитик! Не ленись! Пиши `TRUE` полностью!

В R есть возможность не прописывать полностью логические константы, а использовать только первые буквы от них --- `T` и `F`. Это в принципе будет работать:

```{r oneletter-logic}
class(T); class(F)
T & F
F | F
```

**Однако этим крайне не рекомендуется пользоваться!**

И вот почему. В отличие от `TRUE` и `FALSE` буквы `T` и `F` не защищены от перезаписи и могут служить названием каких-либо переменных. Это может привести к неожиданным последствиям:

```{r oneletter-logic-crush}
T <- 0
T & FALSE

F <- 12.5
F | FALSE
```

Конечно, с целью минимизации возможных ошибок **использовать `T` и `F` в качестве названий переменных не рекомендуется**. Однако кто-то будет следовать этой рекомендации, а кто-то не будет.

Поэтому на всякий случай прописывайте логические константы полностью --- тогда точно подобных казусов удастся избежать.
:::



## Строки {#r-datatypes-character}

:::{.lab-junior}
:::

Текст тоже надо как-то хранить, и для этого существует строковый тип данных `character` (@lst-char-creation).

:::{#lst-char-creation}
```{r}
s1 <- 'a'
s2 <- "это строка"

class(s1)
class(s2)
```

Строки в R
:::

При создании строк не важно[^single-double-quotes], какие кавычки --- одинарные (`''`) или двойные (`""`) --- вы будете использовать. Главное, чтобы открывающиеся и закрывающиеся были одинаковыми. Если же у вас встречаются кавычки внутри кавычек, то надо использовать разные (см. примеры [-@lst-char-quotation1]--[-@lst-char-quotation4]).

[^single-double-quotes]: R не различает в качестве отдельных типов данных «символ» и «строку», как это делают некоторые другие языки программирования, обычно используя одинарные кавычки для создания объекта типа `char` (символ) и двойные для создания объекта типа `string` (строка).

:::{#lst-char-quotation1}
```{r}
s3 <- 'Мужчина громко зашёл в комнату и высказал решительное "здравствуйте"'
s3
```

Кавычки внутри кавычек. Вариант 1
:::

:::{#lst-char-quotation2}
```{r}
s4 <- "Мужчина громко зашёл в комнату и высказал решительное 'здравствуйте'"
s4
```

Кавычки внутри кавычек. Вариант 2
:::

:::{#lst-char-quotation3}
```{r}
s5 <- "Мужчина громко зашёл в комнату и высказал решительное «здравствуйте»"
s5
```

Кавычки внутри кавычек. Вариант 3
:::

:::{#lst-char-quotation4}
```{r}
s6 <- "Мужчина громко зашёл в комнату и высказал решительное “здравствуйте”"
s6
```

Кавычки внутри кавычек. Вариант 4
:::

Первые два варианта (@lst-char-quotation1, @lst-char-quotation2) работают, то есть синтаксически корректны с точки зрения R, хотя и типографически не верны. В первом варианте (@lst-char-quotation1) из-за использования двойных кавычек внутри одинарных возникает необходимость *экранировать* внутренние кавычки с помощью обратного слеша (бэкслеша) (`\"`), чтобы обозначить, что строка не закончилась. Во втором варианте (@lst-char-quotation2) экранирования нет.

Третий вариант (@lst-char-quotation3) с использованием кавычек-ёлочек корректен и с точки зрения типографики, и с точки зрения R. Четвёртый (@lst-char-quotation4) с использованием кавычек-лапок допусти́м с точки зрения типографики, и корректен с точки зрения R.


:::{.callout-note appearance="simple" collapse="true"}
###### Виды кавычек

Раз уж мы заговорили о кавычках, давайте ради полноты картины обсудим, какие они вообще бывают и чем друг от друга отличаются.

* Нас как программистов в первую очередь интересуют **прямые кавычки**. Они могут быть двойными (`"текст"`) или одинарными (`'текст'`). Именно их мы используем при создании строк.
* **Кавычки-лапки** похожи на прямые кавычки, но представляют собой отдельный символ. Они также могут быть одинарными или двойными и встречаются в разных вариантах: `„текст“`, `“текст”`, `‘текст’`. В русской типографической традиции двойные кавычки-лапки в варианте `„текст”` применяются в качестве вложенных кавычек («кавычек внутри кавычек»).
    * В R могут встретиться только при работе с текстами.
* **Кавычки-ёлочки** (`«текст»`) в русской типографической традиции используются в качестве основных и только в двойном варианте. Вообще бывают и одинарные (`‹текст›`), которые отличаются от угловых скобок (`<текст>`).
    * В R могут встретиться только при работе с текстами.
* **Обратные кавычки (бэктики, backticks)** (`` `текст` ``) встречаются в R в разных ситуациях. Мы их уже видели, когда говорили о математических операторах как функциях (@lst-arithm-funs) и встретимся с ними ещё, когда будет говорить о предобработке данных. 

Существуют и [другие варианты](https://en.wikipedia.org/wiki/Quotation_mark#Summary_table) кавычек, но они нам вряд ли когда-либо пригодятся.

:::

Со строками в R можно выполнять множество различных операций. Это довольно объёмная тема, не слишком необходимая нам на первых порах, поэтому мы поговорим о работе со строками [в отдельной главе](r-strings.qmd). Пока же можно отметить, что некоторые операции выполнить со строками нельзя. В частности, невозможно[^char-plus] применить арифметические операторы и функции к строкам (@lst-char-arithm).

:::{#lst-char-arithm}
```{r char-arithm, error=TRUE}
"a" + "b"
"2" + "3"
sum("a", "b", "c")
sum("10", "20", "30")
```

Арифметические операторы и функции со строками
:::

[^char-plus]: Заметьте, что в других языках программирования это не всегда так. Например, команды `"a" + "b"` и `"2" + "3"` в JavaScript отлично сработают, вернув `"ab"` и `"23"` соответственно.



## Приведение типов {#r-datatypes-coercion}

:::{.lab-junior}
:::

В предыдущей главе нам встретился следующий интересный пример (@lst-logic-vs-arithm):

```{r}
6 ^ (6 == 6)
```

Давайте посмотрим на него со всем вниманием. Согласно приоритету операций, сначала вычисляется выражение `6 == 6`, так как оно находится в скобках --- результат будет `TRUE`. Затем выполняется возведение в степень. Но подождите, получается нам необходимо выполнить команду `6 ^ TRUE`, а ведь `TRUE` --- это логическая константа, которую не совсем понятно как употребить в арифметических операциях. Однако всё же ошибки не возникает и в результате получается `6`. В чём же дело?

Здесь в игру вступает **приведение типов (coercion)**. Дело в том, что одни типы данных могут быть приведены с другим. В данном случае логические тип приводится к числовому, то есть `logical` приводится к `numeric`. Что в результате получается, можно понять, посмотрев на результат: так как в итоге получается `6`, то `TRUE` было приведено к `1` --- получаем $6^1 = 6$, кто бы спорил. Мы можем проверить, действительно ли это так, используя специальную функцию, которая приводит данные к числовому типу --- `as.numeric()`:

```{r}
as.numeric(TRUE)
```

Действительно, так и работает. Давайте изучим, как `as.numeric()` обращается в разными входными значениями (@lst-as-numeric).

:::{#lst-as-numeric}
```{r}
as.numeric(TRUE)
as.numeric(FALSE)
as.numeric("1")
as.numeric("0")
as.numeric("-2")
as.numeric("3.5")
as.numeric("-4.68")
as.numeric("six")
```

Приведение к числовому типу данных
:::

Как можно наблюдать, функция работает весьма предсказуемо за исключением последнего случая --- к нему мы вернемся чуть позже.

Приводить данные можно не только к числовому типу --- существуют функции `as.logical()` (@lst-as-logical) и `as.character` (@lst-as-character), работающие аналогично.

:::{#lst-as-logical}
```{r}
as.logical(1)
as.logical(0)
as.logical("TRUE")
as.logical("FALSE")
```

Приведение в логическому типу
:::

:::{#lst-as-character}
```{r}
as.character(TRUE)
as.character(FALSE)
as.character(1)
as.character(0)
as.character(-2)
as.character(3.5)
as.character(-4.68)
```

Приведение к строковому типу
:::

Если приведение типов осуществляется в процессе вычислений или каких-либо преобразований, это **неявное приведение типов** --- как в последнем случае примера [-@lst-logic-vs-arithm]. Если же мы собственными руками выполняем приведение типов, тогда мы имеем дело с **явным приведением типов** --- как в примерах [-@lst-as-numeric], [-@lst-as-logical] и [-@lst-as-character].

Явное приведение типов может пригодится в предобработке данных, когда мы приводим «сырые» данные к нужному для анализа виду. Неявное приведение типов иногда вызывает неожиданное поведение некоторых функций, поэтому стоит помнить о том, что оно существует. В следующей главе мы увидим другие ситуации, в которых оно происходит и обсудим, чем это может быть чревато.

:::{#exr-as-logical}

Хотя приведение данных в логическому типу выглядит весьма предсказуемо (@lst-as-logical), оно обладает некоторыми особенностями. Ниже приведён ряд команд. Предположите, что они должны вернуть, а затем проверьте свои предположения, выполнив эти команды в R.

```{r, eval=FALSE}
as.logical(2)
as.logical(-2)
as.logical(5.5)
as.logical(-5.5)
as.logical("True")
as.logical("False")
as.logical("true")
as.logical("false")
as.logical("T")
as.logical("F")
```

:::

::::{.solution}
:::{.cell}
Приведение чисел к логическим константам производится по следующему правилу:

* `0` → `FALSE`
* любое другое число → `TRUE`

Поэтому имеем следующие результаты:

```{r}
as.logical(2)
as.logical(-2)
as.logical(5.5)
as.logical(-5.5)
```

Выше мы отмечали, что R чувствителен к регистру, что важно при работе с логическими константами (см. @lst-case-sensitivity). Тем не менее, при приведении текста в логическим значениям он менее привередлив: `"TRUE"`, `"T"`, `"True"`, `"true"` будут приведены к значению `TRUE`, а `"FALSE"`, `"F"`, `"False"`, `"false"` --- к `FALSE`. Однако с одиночными буквами в нижнем регистре это не сработает: для `"t"` и `"f"` будет возвращены `NA`.

```{r}
as.logical("True")
as.logical("False")
as.logical("true")
as.logical("false")
as.logical("T")
as.logical("F")
as.logical("t")
as.logical("f")
```

:::
::::



## Специальные константы

:::{.lab-junior}
:::

Кроме логических `TRUE` и `FALSE` в R существует ещё несколько констант, которые используются для обозначения различных странных сущностей.


### `NA`

:::{.lab-junior}
:::

Самая часто встречающаяся вещь. Она используется для обозначения **пропущенных значений** (**N**ot **A**vailable) и обозначает отсутствие значения там, где оно вроде бы должно быть.

Причины существования пропущенных значений могут быть разные:

- технические ошибки записи данных --- данные вообще-то должны быть записаться, но произошёл какой-то баг
- ошибки настройки платформы --- при сборе опросных данных забыли сделать ответы в форме обязательными и респонденты их проигнорировали
- организация исследования --- мы ограничили время на ответ в пробах эксперимента и по завершении пробы ничего не было записано, так как не был дан ответ
- «честный» пропуск --- мы сознательно дали возможность не отвечать на какой-то вопрос
- предобработка данных --- мы специально создали `NA` , чтобы далее с ними работать
- и др.

Пропущенные значения могут стать как полезной, так и довольно неприятной для исследователя ситуацией. С одной стороны, мы может их отдельно анализировать и получать новую информацию об изучаемых объектах. С другой стороны, часто они обозначают отсутствие важных для нас данных, которые мы никак не может восстановить, а кроме того, ломают ожидаемую работу некоторых функций, что мы позже увидим.

Обработка пропущенных значений может стать серьезной задачей в ходе предобработки данных --- в соответствующей теме мы коснёмся этого вопроса.

:::{#exr-na-datatype}
К какому типу данных относятся `NA`?
:::

::::{.solution}
:::{.cell}
```{r}
class(NA)
```

Таким образом, можно сказать, что в R три логических константы --- `TRUE`, `FALSE` и `NA`.
:::
::::



### `NaN`

:::{.lab-junior}
:::

Эта константа обозначает *не число* (**N**ot **a** **N**umber). Она может возникнуть в ходе выполнения вычислений и просигнализирует нам о том, что что-то пошло не так --- мы ожидали в результатах вычислений какое-то численное значения, но не получили его. Например, мы случайно поделили ноль на ноль:

```{r}
0 / 0
```

Конечно, мы вряд ли будет намеренно делить ноль на ноль, однако в ходе предобработки данных и расчётов каких-либо значений такая ситуация возникнуть может, поэтому важно помнить про `NaN` как индикатор потенциальных ошибок в вычислениях.  



### `NULL`

:::{.lab-junior}
:::

Это ничто. Пустота. Используется для задания аргументов функций, когда мы обязаны передать что-то в аргумент, чтобы функция работала, но мы по той или иной причине не хотим туда ничего передавать. Например, вот так:

```{r, eval=FALSE}
ggplot(data = NULL)
```



### `Inf`

:::{.lab-middle}
:::

Иногда в ходе вычислений мы можем получить бесконечность --- для её обозначения используется константа `Inf`. Например, мы решили поделить какое-нибудь число на ноль:

```{r}
6 / 0
```

Опять же мы, скорее всего, получим что-то такое в процессе предобработки данных, а не будем собственноручно сносить данные делением на ноль. `Inf` для нас также будет сигналом о том, что нужно перепроверить произведенные вычисления.

Существует и отрицательная бесконечность --- `-Inf`:

```{r}
-20 / 0
```

:::{#exr-inf-nan}
Что получится, если бесконечность поделить на бесконечность?
:::

:::{.solution}
```{r}
Inf / Inf
-Inf / Inf
Inf / -Inf
-Inf / -Inf
```
:::



## Детали типов данных {#r-datatypes-details}

:::{.lab-senior}
:::

### Типы `NA`

:::{.lab-senior}
:::

* `NA_character_`
* `NA_complex_`
* `NA_integer_`
* `NA_real_`



### `numeric` vs `integer` vs `double` + `typeof()`

:::{.lab-guru}
:::

Вообще говоря, термин `numeric` внутри самого R используется непоследовательно [см. @wickham-advr-2019, sec. 12.3.1]. С одной стороны, `numeric` используется для обозначения чисел, содержащих дробную часть. В этом смысле он оказывается синонимом к типу `double`[^double], который также существует, но достаётся с помощью функции `typeof()`, которая «более низкоуровневая»:

```{r class-and-typeof-numeric}
class(2.20)
typeof(2.20)
```

[^double]: Это наводит нас на мысль, что числа с плавающей точкой хранятся в R с двойной точностью --- и это правда. Подробнее см. [приложение](appendix-numbers-iron.qmd).

Две функции --- `class` и `typeof` --- согласны и в отношении целочисленного типа данных:

```{r class-and-typeof-integer}
class(2L)
typeof(2L)
```

Однако если залезть глубже и посмотреть на числа с точки зрения ООП, то можно обнаружить неожиданное:

```{r sloop-numers}
sloop::s3_class(1)
sloop::s3_class(1L)
```

И у целого числа, и у числа с плавающей точкой есть атрибут `numeric`. Получается, что `numeric` является обобщением для типов `integer` и `double`.



### `complex` {#r-datatypes-complex}

:::{.lab-senior}
:::

В R существуют и комплексные числа[^complex-num]. Они крайне редко встречаются в статистике и анализе данных --- разве что при выводе каких-нибудь теорем в суровой математической части статистики. Соответственно, в практической работе они вам вряд ли встретятся.

[^complex-num]: Кто это такие, описывается в [приложении](appendix-numbers.qmd#appendix-numbers-c).

Однако даже если вы не понимаете, кто такие есть эти числа, вы все равно можете с ними взаимодействовать в R --- ведь это просто некие числа. Да, со своими приколами и особенностями, но всё же числа. А значит с ними можно выполнять все операции, которые можно выполнять с другими числами.

:::{#lst-complex-num}
```{r complex-num}
class(2+3i)
8-6i + 2+3i
(8-6i) * (2+3i)
(-7-1.5i) / (1.1i)
sqrt(-12+0i)
```

Операции с комплексными числами
:::


***

###### Session Info {#session_info .unnumbered}

```{r session-info}
sessionInfo()
```

```{=html}
<script type="text/javascript" src="./js/chapter.js"></script>
```
