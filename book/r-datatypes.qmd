# Типы данных {#r-datatypes}

{{< include other/_symbols.qmd >}}

```{r opts, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, error=FALSE}
knitr::opts_chunk$set(echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, error=FALSE)
```

```{r pkgs, echo=FALSE}
library(tidyverse)
theme_set(theme_bw())
library(rvest)
```

:::{.intro}
В прошлой главе мы познакомились с самыми базовыми основами работы в R. В этой и следующей главе мы разберемся в фундаментальных сущностях языка --- типах и структурах данных. Ведь в итоге бы хотим освоить R для работы с данными --- давайте разберемся, что в этих данных бывает.

Мы уже неизбежно столкнулись с данными --- как минимум в прошлой главе у нас были числа, над которыми мы выполняли математические операции, а также нечто, имеющее значение `TRUE` и `FALSE`, получавшееся после сравнений. Что ж, займемся структурированием и расширением этого эмпирического опыта.
:::

## Концепт «тип данных» {#r-datatypes-concept}

:::{.lab-junior}
:::

Что вообще такое тип данных? Определение можно дать много разных, но все они сводятся к следующей идее:

:::{#def-datatype}
**Тип данных** --- это характеристика данных, которая определяет **допустимые значения**, которые могут принимать данные этого типа, и **допустимые операции** над данными этого типа [@iso24765-2017].
:::

:::{.quote .small}
--- Это, конечно, хорошо. Но что это означает на деле? <br>
--- Сейчас разберемся, рассмотрев типы данных в R.
:::

Стоит отметить, что в разных языках программирования выделяются разные типы данных, а в сущности одни и те же типы могут называться по-разному. Мы, разумеется, будем рассматривать типы данных языка R, ибо изучаем именно его, однако сопоставить их с типами данных других языков программирования на составляет труда.



## Числа {#r-datatypes-numbers}

:::{.lab-junior}
:::

Первое, с чем должно быть возможно работать, это, конечно же, числа. Для них в R предусмотрен тип `numeric`.


### `numeric` {#r-datatypes-numeric}

:::{.lab-junior}
:::

Как нам удостовериться в очевидном факте, что `2` --- это число? Для этого в R существует функция `class()`, которая позволяет узнать тип данных конкретного объекта.

Узнаем, действительно ли `2` является числом:

:::{#lst-class-of-2}
```{r class-of-2}
class(2)
```

Работа функции `class()`
:::

Аналогично, можем убедиться, что `3.14` также является числом:

```{r class-of-3-14}
class(3.14)
```

Функция `class()` также успешно справится и с переменными. Например,

```{r class-var}
x <- cos(4)
x
class(x)
```



#### Что можно сделать с числом? {#r-datatypes-numfun}

С числами, как и следовало ожидать, **можно выполнять все математические операции** --- складывать, вычитать, делить, умножать и т. д. --- а также **вызывать на них математические функции** --- корни, логарифмы, экспоненты, синусы и др. Собственно, этим мы занимались в предыдущей главе. Давайте вспомним.

Создадим три числовые переменные `x`, `y` и `z` и поразвлекаемся.

```{r numfun-vars}
x <- 3.5
y <- 5.67
z <- -12.3
```

Уже знакомые нам математические операции:

:::{#lst-numfun-arithm}

```{r numfun-arithm}
x + y # сложение
x - y # вычитание
x * y # умножение
x / y # деление
x %/% y # целочисленное деление
y %/% x # целочисленное деление
y %% x # взятие остатка от деления
x ^ y # возведение в степень
```

Математические операции с числовыми переменными
:::

Знакомые и новые математические функции:

:::{#lst-numfun-funcs}

```{r numfun-funcs}
log(x, y) # логарифм
sqrt(x) # квадратный корень
sin(x); cos(x); tan(x)  # тригонометрия
exp(x) # экспонента, e^x
abs(z) # модуль
sum(x, y, z) # сумма нескольких переменных
round(y, 1) # округлить до заданного числа знаков после точки
ceiling(z) # округлить до ближайшего целого вверх
floor(z) # округлить до ближайшего целого вниз
```

Математические функции с числовыми переменными
:::

В общем, арсенал вполне приличный.



### `integer` {#r-datatypes-integer}

:::{.lab-middle}
:::

Дотошный читатель, имевший опыт работы с другими языками программирования, мог озадачиться, увидев @lst-class-of-2. Отчасти справедливо, так как $2$ --- это целое число, а практически во всех языках программирования под целые числа выделяется отдельный тип данных[^datatype-integer].

В R такой тип данных тоже есть, и называется он классически `integer`. Однако **по умолчанию все числа рассматриваются в R как `numeric`.** Иначе говоря, запись `2` рассматривается как `2.0`. Это довольно удобно для аналитических задач, где у нас целые числа появляются не то чтобы часто.

[^datatype-integer]: Это связано с различиями в способе хранения целых чисел и чисел с плавающей точкой. Подробнее см. [приложение](appendix-numbers-iron.qmd).

Тем не менее, создать целое число всё же можно --- для этого надо указать, что нам нужно именно целое число с помощью буквы `L` сразу после числа[^integer-L]. Например, чтобы положить в переменную целое число $2$, нужно записать так:

```{r integer-2}
y <- 2L
```

[^integer-L]: Литерал `L` обозначает, что это `long integer` [@wickham-advr-2019]. Подробнее см. [приложение](appendix-numbers-iron.qmd).

Мы можем удостовериться, что `y` --- это переменная целочисленного типа, то есть `integer`:

```{r class-integer}
class(y)
```

Едва ли вам придется когда-либо вручную прописывать, что необходимы именно целочисленные значения переменной. Однако вы с ними можете столкнуться при работе с циклами --- они там появляются сами, и если не знать, что это такое, можно сильно удивиться числу, например, `11L`.

Для целых чисел выполняются те же операции, что и для чисел типа `numeric`:

:::{#lst-numfun-integer}

```{r numfun-integer}
a <- 24L
b <- 12L
c <- -7L

a + b # сложение
a - b # вычитание
a * b # умножение
a / b # деление
a %/% b # целочисленное деление
a %/% c # целочисленное деление
a %% c # взятие остатка от деления
a ^ b # возведение в степень
a ^ c # возведение в степень

log(a, b) # логарифм
sqrt(a) # квадратный корень
sin(a); cos(b); tan(c)  # тригонометрия
exp(a) # экспонента, e^x
abs(c) # модуль
sum(a, b, c) # сумма нескольких переменных
```

Математические операции и функции на целочисленных переменных
:::

Функции округления бессмысленны, так как числа изначально целые, то есть не имеют дробной части.



### `numeric` vs `integer` vs `double` + `typeof()`

:::{.lab-guru}
:::

Вообще говоря, термин `numeric` внутри самого R используется непоследовательно [см. @wickham-advr-2019, sec. 12.3.1]. С одной стороны, `numeric` используется для обозначения чисел, содержащих дробную часть. В этом смысле он оказывается синонимом к типу `double`[^double], который также существует, но достаётся с помощью функции `typeof()`, которая «более низкоуровневая»:

```{r class-and-typeof-numeric}
class(2.20)
typeof(2.20)
```

[^double]: Это наводит нас на мысль, что числа с плавающей точкой хранятся в R с двойной точностью --- и это правда. Подробнее см. [приложение](appendix-numbers-iron.qmd).

Две функции --- `class` и `typeof` --- согласны и в отношении целочисленного типа данных:

```{r class-and-typeof-integer}
class(2L)
typeof(2L)
```

Однако если залезть глубже и посмотреть на числа с точки зрения ООП, то можно обнаружить неожиданное:

```{r sloop-numers}
sloop::s3_class(1)
sloop::s3_class(1L)
```

И у целого числа, и у числа с плавающей точкой есть атрибут `numeric`. Получается, что `numeric` является обобщением для типов `integer` и `double`.



### `complex` {#r-datatypes-complex}

:::{.lab-senior}
:::

В R существуют и комплексные числа[^complex-num]. Они крайне редко встречаются в статистике и анализе данных --- разве что при выводе каких-нибудь теорем в суровой математической части статистики. Соответственно, в практической работе они вам вряд ли встретятся.

[^complex-num]: Кто это такие, описывается в [приложении](appendix-numbers.qmd#appendix-numbers-c).

Однако даже если вы не понимаете, кто такие есть эти числа, вы все равно можете с ними взаимодействовать в R --- ведь это просто некие числа. Да, со своими приколами и особенностями, но всё же числа. А значит с ними можно выполнять все операции, которые можно выполнять с другими числами.

:::{#lst-complex-num}
```{r complex-num}
class(2+3i)
8-6i + 2+3i
(8-6i) * (2+3i)
(-7-1.5i) / (1.1i)
sqrt(-12+0i)
```

Операции с комплексными числами
:::



## `logical` {#r-datatypes-logical}

:::{.lab-junior}
:::


:::{.callout-important}
###### Case sensitivity

R чувствителен к регистру (case sensitive), поэтому `TRUE`, `true` и `True` --- это разные сущности!
:::

:::{.callout-caution}
###### Аналитик! Не ленись! Пиши `TRUE` полностью!

T и TRUE
:::

### Логические операторы


## `character`

Текст тоже надо как-то хранить.

```{r}
s1 <- 'a'
s2 <- "это строка"

class(s1)
class(s2)
```

Кавычки не важны, если у вас не встречаются кавычки внутри кавычек. Тогда надо использовать разные:

```{r}
s <- 'Мужчина громко зашёл в комнату и высказал решительное "здравствуйте"'
s
```

## `factor`

Бывают такие переменные, которые группируют наши данные. Например,

- город проживания (`Москва`, `Санкт-Петербург`, `Казань`, `Екатеринбург`)
- уровень образования (`бакалавриат`, `специалитет`, `магистратура`, `аспирантура`)
- экспериментальная группа (`group1`, `group2`, `control`)
- и др.

Обычно они текстовые. Для них был придуман тип данных `factor`, чтобы их было дешевле хранить. Однако большинство современных пакетов сами могут решить, когда надо текст перевести в фактор.

`Ordered factor` (**упорядоченный фактор**) --- тип данных, который позволяет задать порядок групп. Например,

- уровень образования: `bachelor` < `master` < `phd` < `postdoc`
- сложность экспериментальной задачи: `easy` < `medium` < `hard`
- и др.

Вот упорядоченный фактор нам время от времени может понадобиться --- например, для создания визуалиация или в некоторых статистических моделях.

```{r}
typeof(factor("x"))
is.integer(factor("x"))
is.numeric(factor("x"))
```


## Приведение типов

@lst-logic-vs-arithm

## Специальные литералы

### `NA`

Пропущенное значение (**N**ot **A**vailable). Обозначает отсутствие значения там, где оно вроде бы должно быть. Причины могут быть разные:

- технические ошибки записи данных
- ошибки настройки платформы --- забыли сделать ответы обязательными
- организация исследования --- ограничили время на ответ
- «честный» пропуск --- дали возможность не отвечать на вопрос
- предобработка данных --- специально создали `NA`, чтобы далее с ними работать
- и др.


### `NaN`

Это не число (**N**ot **a** **N**umber).

```{r}
0 / 0
```


### `NULL`

Это ничто. Пустота. Используется для задания аргументов функций.

```{r, eval=FALSE}
ggplot(data = NULL)
```


***

###### Session Info {#session_info .unnumbered}

```{r session-info}
sessionInfo()
```

```{=html}
<script type="text/javascript" src="./js/chapter.js"></script>
```
